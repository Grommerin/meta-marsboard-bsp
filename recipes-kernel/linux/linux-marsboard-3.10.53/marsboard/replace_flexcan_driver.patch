--- a/drivers/net/can/flexcan.c	2016-03-28 15:59:08.375248978 +0300
+++ a/drivers/net/can/flexcan.c	2016-03-28 15:46:19.372264829 +0300
@@ -1,30 +1,29 @@
-/*
- * flexcan.c - FLEXCAN CAN controller driver
- *
- * Copyright (c) 2005-2006 Varma Electronics Oy
- * Copyright (c) 2009 Sascha Hauer, Pengutronix
- * Copyright (c) 2010 Marc Kleine-Budde, Pengutronix
- *
- * Based on code originally by Andrey Volkov <avolkov@varma-el.com>
- *
- * LICENCE:
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
+/**
+ * @file flexcan.c
+ * @brief FLEXCAN CAN controller driver
+ * @details This file is driver for work with flexcan controller
+ * @version 1.1.25
+ * @date 04.04.2015
+ * @author Mikita Dzivakou
+ * @copyright (c) 2005-2006 Varma Electronics Oy
+ * @copyright (c) 2009 Sascha Hauer, Pengutronix
+ * @copyright (c) 2010 Marc Kleine-Budde, Pengutronix
+ * @copyright (c) 2015 Mikita Dzivakou, Strim-tech
+ * @verbatim
+   LICENCE:
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation version 2.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ * @endverbatim
  */
 
-#include <linux/netdevice.h>
-#include <linux/can.h>
-#include <linux/can/dev.h>
+// #include <linux/netdevice.h>
 #include <linux/can/error.h>
-#include <linux/can/led.h>
-#include <linux/can/platform/flexcan.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/if_arp.h>
@@ -33,123 +32,162 @@
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
-#include <linux/mfd/syscon.h>
-#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
-#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/time.h>
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/kdev_t.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+
+//#include <mach/clock.h>
+//#include <mach/hardware.h>
+// #include <mach/iomux-v3.h>
 
-#define DRV_NAME			"flexcan"
+#include "chr_flexcan.h"
 
-/* 8 for RX fifo and 2 error handling */
-#define FLEXCAN_NAPI_WEIGHT		(8 + 2)
+#ifdef CONFIG_ARCH_MXC
+	//#include <mach/iomux-v3.h>
+#endif
 
 /* FLEXCAN module configuration register (CANMCR) bits */
-#define FLEXCAN_MCR_MDIS		BIT(31)
-#define FLEXCAN_MCR_FRZ			BIT(30)
-#define FLEXCAN_MCR_FEN			BIT(29)
-#define FLEXCAN_MCR_HALT		BIT(28)
-#define FLEXCAN_MCR_NOT_RDY		BIT(27)
-#define FLEXCAN_MCR_WAK_MSK		BIT(26)
-#define FLEXCAN_MCR_SOFTRST		BIT(25)
-#define FLEXCAN_MCR_FRZ_ACK		BIT(24)
-#define FLEXCAN_MCR_SUPV		BIT(23)
-#define FLEXCAN_MCR_SLF_WAK		BIT(22)
-#define FLEXCAN_MCR_WRN_EN		BIT(21)
-#define FLEXCAN_MCR_LPM_ACK		BIT(20)
-#define FLEXCAN_MCR_WAK_SRC		BIT(19)
-#define FLEXCAN_MCR_DOZE		BIT(18)
-#define FLEXCAN_MCR_SRX_DIS		BIT(17)
-#define FLEXCAN_MCR_BCC			BIT(16)
-#define FLEXCAN_MCR_LPRIO_EN		BIT(13)
-#define FLEXCAN_MCR_AEN			BIT(12)
-#define FLEXCAN_MCR_MAXMB(x)		((x) & 0x1f)
-#define FLEXCAN_MCR_IDAM_A		(0 << 8)
-#define FLEXCAN_MCR_IDAM_B		(1 << 8)
-#define FLEXCAN_MCR_IDAM_C		(2 << 8)
-#define FLEXCAN_MCR_IDAM_D		(3 << 8)
+#define FLEXCAN_MCR_MDIS				BIT(31)
+#define FLEXCAN_MCR_FRZ					BIT(30)
+#define FLEXCAN_MCR_FEN					BIT(29)
+#define FLEXCAN_MCR_HALT				BIT(28)
+#define FLEXCAN_MCR_NOT_RDY				BIT(27)
+#define FLEXCAN_MCR_WAK_MSK				BIT(26)
+#define FLEXCAN_MCR_SOFTRST				BIT(25)
+#define FLEXCAN_MCR_FRZ_ACK				BIT(24)
+#define FLEXCAN_MCR_SUPV				BIT(23)
+#define FLEXCAN_MCR_SLF_WAK				BIT(22)
+#define FLEXCAN_MCR_WRN_EN				BIT(21)
+#define FLEXCAN_MCR_LPM_ACK				BIT(20)
+#define FLEXCAN_MCR_WAK_SRC				BIT(19)
+#define FLEXCAN_MCR_DOZE				BIT(18)
+#define FLEXCAN_MCR_SRX_DIS				BIT(17)
+#define FLEXCAN_MCR_BCC					BIT(16)
+#define FLEXCAN_MCR_LPRIO_EN			BIT(13)
+#define FLEXCAN_MCR_AEN					BIT(12)
+#define FLEXCAN_MCR_MAXMB(x)			((x) & 0xf)
+#define FLEXCAN_MCR_IDAM_A				(0 << 8)
+#define FLEXCAN_MCR_IDAM_B				(1 << 8)
+#define FLEXCAN_MCR_IDAM_C				(2 << 8)
+#define FLEXCAN_MCR_IDAM_D				(3 << 8)
 
 /* FLEXCAN control register (CANCTRL) bits */
-#define FLEXCAN_CTRL_PRESDIV(x)		(((x) & 0xff) << 24)
-#define FLEXCAN_CTRL_RJW(x)		(((x) & 0x03) << 22)
-#define FLEXCAN_CTRL_PSEG1(x)		(((x) & 0x07) << 19)
-#define FLEXCAN_CTRL_PSEG2(x)		(((x) & 0x07) << 16)
-#define FLEXCAN_CTRL_BOFF_MSK		BIT(15)
-#define FLEXCAN_CTRL_ERR_MSK		BIT(14)
-#define FLEXCAN_CTRL_CLK_SRC		BIT(13)
-#define FLEXCAN_CTRL_LPB		BIT(12)
-#define FLEXCAN_CTRL_TWRN_MSK		BIT(11)
-#define FLEXCAN_CTRL_RWRN_MSK		BIT(10)
-#define FLEXCAN_CTRL_SMP		BIT(7)
-#define FLEXCAN_CTRL_BOFF_REC		BIT(6)
-#define FLEXCAN_CTRL_TSYN		BIT(5)
-#define FLEXCAN_CTRL_LBUF		BIT(4)
-#define FLEXCAN_CTRL_LOM		BIT(3)
-#define FLEXCAN_CTRL_PROPSEG(x)		((x) & 0x07)
-#define FLEXCAN_CTRL_ERR_BUS		(FLEXCAN_CTRL_ERR_MSK)
-#define FLEXCAN_CTRL_ERR_STATE \
-	(FLEXCAN_CTRL_TWRN_MSK | FLEXCAN_CTRL_RWRN_MSK | \
-	 FLEXCAN_CTRL_BOFF_MSK)
-#define FLEXCAN_CTRL_ERR_ALL \
-	(FLEXCAN_CTRL_ERR_BUS | FLEXCAN_CTRL_ERR_STATE)
+#define FLEXCAN_CTRL_PRESDIV(x)			(((x) & 0xff) << 24)
+#define FLEXCAN_CTRL_RJW(x)				(((x) & 0x03) << 22)
+#define FLEXCAN_CTRL_PSEG1(x)			(((x) & 0x07) << 19)
+#define FLEXCAN_CTRL_PSEG2(x)			(((x) & 0x07) << 16)
+#define FLEXCAN_CTRL_BOFF_MSK			BIT(15)
+#define FLEXCAN_CTRL_ERR_MSK			BIT(14)
+#define FLEXCAN_CTRL_CLK_SRC			BIT(13)
+#define FLEXCAN_CTRL_LPB				BIT(12)
+#define FLEXCAN_CTRL_TWRN_MSK			BIT(11)
+#define FLEXCAN_CTRL_RWRN_MSK			BIT(10)
+#define FLEXCAN_CTRL_SMP				BIT(7)
+#define FLEXCAN_CTRL_BOFF_REC			BIT(6)
+#define FLEXCAN_CTRL_TSYN				BIT(5)
+#define FLEXCAN_CTRL_LBUF				BIT(4)
+#define FLEXCAN_CTRL_LOM				BIT(3)
+#define FLEXCAN_CTRL_PROPSEG(x)			((x) & 0x07)
+
+#define FLEXCAN_CTRL_ERR_BUS			(FLEXCAN_CTRL_ERR_MSK)
+#define FLEXCAN_CTRL_ERR_STATE 			(FLEXCAN_CTRL_TWRN_MSK | FLEXCAN_CTRL_RWRN_MSK | FLEXCAN_CTRL_BOFF_MSK)
+#define FLEXCAN_CTRL_ERR_ALL 			(FLEXCAN_CTRL_ERR_BUS | FLEXCAN_CTRL_ERR_STATE)
 
 /* FLEXCAN error and status register (ESR) bits */
-#define FLEXCAN_ESR_TWRN_INT		BIT(17)
-#define FLEXCAN_ESR_RWRN_INT		BIT(16)
-#define FLEXCAN_ESR_BIT1_ERR		BIT(15)
-#define FLEXCAN_ESR_BIT0_ERR		BIT(14)
-#define FLEXCAN_ESR_ACK_ERR		BIT(13)
-#define FLEXCAN_ESR_CRC_ERR		BIT(12)
-#define FLEXCAN_ESR_FRM_ERR		BIT(11)
-#define FLEXCAN_ESR_STF_ERR		BIT(10)
-#define FLEXCAN_ESR_TX_WRN		BIT(9)
-#define FLEXCAN_ESR_RX_WRN		BIT(8)
-#define FLEXCAN_ESR_IDLE		BIT(7)
-#define FLEXCAN_ESR_TXRX		BIT(6)
-#define FLEXCAN_EST_FLT_CONF_SHIFT	(4)
-#define FLEXCAN_ESR_FLT_CONF_MASK	(0x3 << FLEXCAN_EST_FLT_CONF_SHIFT)
-#define FLEXCAN_ESR_FLT_CONF_ACTIVE	(0x0 << FLEXCAN_EST_FLT_CONF_SHIFT)
-#define FLEXCAN_ESR_FLT_CONF_PASSIVE	(0x1 << FLEXCAN_EST_FLT_CONF_SHIFT)
-#define FLEXCAN_ESR_BOFF_INT		BIT(2)
-#define FLEXCAN_ESR_ERR_INT		BIT(1)
-#define FLEXCAN_ESR_WAK_INT		BIT(0)
-#define FLEXCAN_ESR_ERR_BUS \
-	(FLEXCAN_ESR_BIT1_ERR | FLEXCAN_ESR_BIT0_ERR | \
-	 FLEXCAN_ESR_ACK_ERR | FLEXCAN_ESR_CRC_ERR | \
-	 FLEXCAN_ESR_FRM_ERR | FLEXCAN_ESR_STF_ERR)
-#define FLEXCAN_ESR_ERR_STATE \
-	(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | FLEXCAN_ESR_BOFF_INT)
-#define FLEXCAN_ESR_ERR_ALL \
-	(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)
-#define FLEXCAN_ESR_ALL_INT \
-	(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | \
-	 FLEXCAN_ESR_BOFF_INT | FLEXCAN_ESR_ERR_INT | \
-	 FLEXCAN_ESR_WAK_INT)
+#define FLEXCAN_ESR_TWRN_INT           BIT(17)
+#define FLEXCAN_ESR_RWRN_INT           BIT(16)
+#define FLEXCAN_ESR_BIT1_ERR           BIT(15)
+#define FLEXCAN_ESR_BIT0_ERR           BIT(14)
+#define FLEXCAN_ESR_ACK_ERR            BIT(13)
+#define FLEXCAN_ESR_CRC_ERR            BIT(12)
+#define FLEXCAN_ESR_FRM_ERR            BIT(11)
+#define FLEXCAN_ESR_STF_ERR            BIT(10)
+#define FLEXCAN_ESR_TX_WRN             BIT(9)
+#define FLEXCAN_ESR_RX_WRN             BIT(8)
+#define FLEXCAN_ESR_IDLE               BIT(7)
+#define FLEXCAN_ESR_TXRX               BIT(6)
+#define FLEXCAN_EST_FLT_CONF_SHIFT     (4)
+#define FLEXCAN_ESR_FLT_CONF_MASK      (0x3 << FLEXCAN_EST_FLT_CONF_SHIFT)
+#define FLEXCAN_ESR_FLT_CONF_ACTIVE    (0x0 << FLEXCAN_EST_FLT_CONF_SHIFT)
+#define FLEXCAN_ESR_FLT_CONF_PASSIVE   (0x1 << FLEXCAN_EST_FLT_CONF_SHIFT)
+#define FLEXCAN_ESR_BOFF_INT           BIT(2)
+#define FLEXCAN_ESR_ERR_INT            BIT(1)
+#define FLEXCAN_ESR_WAK_INT            BIT(0)
+
+#define FLEXCAN_ESR_ERR_BUS 			(FLEXCAN_ESR_BIT1_ERR | FLEXCAN_ESR_BIT0_ERR | FLEXCAN_ESR_ACK_ERR | \
+										 FLEXCAN_ESR_CRC_ERR | FLEXCAN_ESR_FRM_ERR | FLEXCAN_ESR_STF_ERR)
+#define FLEXCAN_ESR_ERR_STATE 			(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | FLEXCAN_ESR_BOFF_INT)
+#define FLEXCAN_ESR_ERR_ALL 			(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)
 
 /* FLEXCAN interrupt flag register (IFLAG) bits */
-#define FLEXCAN_RESERVED_BUF_ID		8
-#define FLEXCAN_TX_BUF_ID		13
-#define FLEXCAN_IFLAG_BUF(x)		BIT(x)
-#define FLEXCAN_IFLAG_RX_FIFO_OVERFLOW	BIT(7)
-#define FLEXCAN_IFLAG_RX_FIFO_WARN	BIT(6)
-#define FLEXCAN_IFLAG_RX_FIFO_AVAILABLE	BIT(5)
-#define FLEXCAN_IFLAG_DEFAULT \
-	(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW | FLEXCAN_IFLAG_RX_FIFO_AVAILABLE | \
-	 FLEXCAN_IFLAG_BUF(FLEXCAN_TX_BUF_ID))
+#define FLEXCAN_TX_BUF_ID                  8
+#define FLEXCAN_IFLAG_BUF(x)               BIT(x)
+#define FLEXCAN_IFLAG_RX_FIFO_OVERFLOW     BIT(7)
+#define FLEXCAN_IFLAG_RX_FIFO_WARN	        BIT(6)
+#define FLEXCAN_IFLAG_RX_FIFO_AVAILABLE    BIT(5)
+
+#define FLEXCAN_IFLAG_DEFAULT          (FLEXCAN_IFLAG_RX_FIFO_OVERFLOW | FLEXCAN_IFLAG_RX_FIFO_AVAILABLE | FLEXCAN_IFLAG_BUF(FLEXCAN_TX_BUF_ID))
 
 /* FLEXCAN message buffers */
-#define FLEXCAN_MB_CNT_CODE(x)		(((x) & 0xf) << 24)
-#define FLEXCAN_MB_CNT_SRR		BIT(22)
-#define FLEXCAN_MB_CNT_IDE		BIT(21)
-#define FLEXCAN_MB_CNT_RTR		BIT(20)
-#define FLEXCAN_MB_CNT_LENGTH(x)	(((x) & 0xf) << 16)
-#define FLEXCAN_MB_CNT_TIMESTAMP(x)	((x) & 0xffff)
+#define FLEXCAN_MB_CNT_CODE(x)         (((x) & 0xf) << 24)
+#define FLEXCAN_MB_CNT_SRR             BIT(22)
+#define FLEXCAN_MB_CNT_IDE             BIT(21)
+#define FLEXCAN_MB_CNT_RTR             BIT(20)
+#define FLEXCAN_MB_CNT_LENGTH(x)       (((x) & 0xf) << 16)
+#define FLEXCAN_MB_CNT_TIMESTAMP(x)    ((x) & 0xffff)
+
+#define FLEXCAN_MB_CODE_MASK           (0xf0ffffff)
+
+
+#define FLEXCAN_BTRT_1000_SP866    (0x01290005)
+#define FLEXCAN_BTRT_1000_SP800    (0x012a0004)
+#define FLEXCAN_BTRT_1000_SP733    (0x01230004)
+#define FLEXCAN_BTRT_1000_SP700    (0x02120002)
+
+#define FLEXCAN_BTRT_1000          (0x01290005)
+#define FLEXCAN_BTRT_500           (0x023b0006)		/* Предварительно, настройка рассчитана через canconfig */
+#define FLEXCAN_BTRT_250           (0x053b0006)		/* Предварительно, настройка рассчитана через canconfig */
+#define FLEXCAN_BTRT_125           (0x0b3b0006)		/* Предварительно, настройка рассчитана через canconfig */
+#define FLEXCAN_BTRT_100           (0x0e3b0006)		/* Предварительно, настройка рассчитана через canconfig */
+#define FLEXCAN_BTRT_DFLT          FLEXCAN_BTRT_1000
+
+#define FLEXCAN_BTRT_MASK          (0xFFFF0007)
+
+#define FLEXCAN_DRV_NAME           "flexcan"
+#define FLEXCAN_DRV_VER            "1.3.00"
+
+#define FLEXCAN_DEV_FIRST          (0)
+#define FLEXCAN_DEV_COUNT          (2)
+
+#define FLEXCAN_BUF_RECV_CAP       (262144)
+#define FLEXCAN_BUF_SEND_CAP       (64)
+
+#define FLEXCAN_BUF_RECV_MASK      (fimx6d.f_dev[dev_num].buf_recv_size - 1)
+#define FLEXCAN_BUF_SEND_MASK      (fimx6d.f_dev[dev_num].buf_send_size - 1)
+
+#define FLEXCAN_IRQ_BASE           (142)
 
-#define FLEXCAN_MB_CODE_MASK		(0xf0ffffff)
+#define init_MUTEX(LOCKNAME) sema_init(LOCKNAME,1);
+
+#define FLEXCAN_TIMEOUT_US         (50)
 
 /*
  * FLEXCAN hardware feature flags
@@ -169,13 +207,6 @@
 #define FLEXCAN_HAS_BROKEN_ERR_STATE	BIT(2) /* [TR]WRN_INT not connected */
 #define FLEXCAN_HAS_ERR005829		BIT(3) /* have errata ERR005829 */
 
-/* Structure of the message buffer */
-struct flexcan_mb {
-	u32 can_ctrl;
-	u32 can_id;
-	u32 data[2];
-};
-
 /* Structure of the hardware registers */
 struct flexcan_regs {
 	u32 mcr;		/* 0x00 */
@@ -193,8 +224,7 @@
 	u32 iflag1;		/* 0x30 */
 	u32 crl2;		/* 0x34 */
 	u32 esr2;		/* 0x38 */
-	u32 imeur;		/* 0x3c */
-	u32 lrfr;		/* 0x40 */
+	u32 _reserved2[2];
 	u32 crcr;		/* 0x44 */
 	u32 rxfgmask;		/* 0x48 */
 	u32 rxfir;		/* 0x4c */
@@ -202,36 +232,146 @@
 	struct flexcan_mb cantxfg[64];
 };
 
-struct flexcan_devtype_data {
-	u32 features;	/* hardware controller features */
+enum flexcan_ip_version {
+	FLEXCAN_VER_3_0_0,
+	FLEXCAN_VER_3_0_4,
+	FLEXCAN_VER_10_0_12,
+};
+
+static struct can_bittiming_const flexcan_bittiming_const = {
+	.name = FLEXCAN_DRV_NAME,
+	.tseg1_min = 4,
+	.tseg1_max = 16,
+	.tseg2_min = 2,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
 };
 
-struct flexcan_stop_mode {
-	struct regmap *gpr;
-	u8 req_gpr;
-	u8 req_bit;
-	u8 ack_gpr;
-	u8 ack_bit;
+typedef struct {
+	unsigned int n_push, n_pop, n_save_pop;
+} circle_buf_t;
+
+struct flexcan_frame_mb {
+	struct flexcan_mb mb;
+	struct timeval time;
 };
-struct flexcan_priv {
-	struct can_priv can;
-	struct net_device *dev;
-	struct napi_struct napi;
 
-	void __iomem *base;
-	u32 reg_esr;
+struct flexcan_chardev {
+
+/* Имя устройства.
+ * Это же имя отдается файлу устройства в /dev и /proc */
+	char name[IFNAMSIZ];
+
+/* Содержит major и minor номер зарегистрированного устройства
+ * Номера извлекаются макросами MAJOR(dev_t devt) и MINOR(dev_t devt)
+ * Номер формируется при регистрации устройства автоматически
+ * Так же формируется макросом MKDEV(major, minor) */
+	dev_t f_devt;
+
+/* Адрес начала блока памяти устройства
+ * Сохраняется при регистрации устройства
+ * Используется для чтения регистров устройства с помощью struct flexcan_regs */
+	void __iomem *f_base;
+
+/* Номер вектора прерывания IRQ для устройства */
+	u8 irq_num;
+
+/* Флаг открытия файла устройства
+ * Нужен для предотвращения множественного доступа к файлу
+ * (а еще для запрета удаления драйвера при открытом файле, но не реализовано) */
+ 	int nreaders, nwriters;
+
+/* Значение регистра CTRL для настройки скорости передачи и режима работы
+ * При инициализации устанавливается значение по умолчанию FLEXCAN_BTRT_DFLT
+ * Изменяется через IOCTL запрос */
+	u32 reg_ctrl_bittiming;
+
+/* Значение по умолчанию регистра CTRL для будущих использований
+ * Создается в функции chip_start */
 	u32 reg_ctrl_default;
 
+/* Структура символьного утсройства */
+	struct cdev f_cdev;	
+
+/* Структура утсройства */
+	struct device dev;	
+
+/* Указатель на структуру встроенного в контроллер устройства flexcan */
+	struct flexcan_platform_data *pdata;
+
+/* Структура с данными файла устройства в файловой системе /proc  */
+	struct proc_dir_entry *dev_proc_file;
+
+/* Структура с данными по тактированию устройства */
 	struct clk *clk_ipg;
+
+/* Структура с данными по тактированию устройства */
 	struct clk *clk_per;
-	struct flexcan_platform_data *pdata;
-	const struct flexcan_devtype_data *devtype_data;
-	struct flexcan_stop_mode stm;
-	int stby_gpio;
-	enum of_gpio_flags stby_gpio_flags;
-	int id;
+
+/* Структура с параметрами регулятора */
+	struct regulator *reg_xceiver;
+
+/* Структура с данными о настройках таймингов устройства */
+	struct can_bittiming bittiming;
+
+/* Структура с данными о состоянии и работе устройства
+ * Содержит различные счетчики и переменные состояния устройства */
+	struct flexcan_stats stats;
+
+/* Размер буфера для сохранения принятых сообщений */
+	u32 buf_recv_size;
+
+/* Номера ячеек для записи и чтения циклического буффера для сохранения */
+	circle_buf_t frame_buf_recv;
+
+/* Циклический буффер для сохранения принятых сообщений */
+	struct flexcan_frame_mb buf_recv[FLEXCAN_BUF_RECV_CAP];
+
+/* Размер буфера для сохранения сообщений на отправку */
+	u32 buf_send_size;
+
+/* Номера ячеек для записи и чтения циклического буффера сообщений на отправку  */
+	circle_buf_t frame_buf_send;
+
+/* Циклический буффер для сохранения сообщений на отправку */
+	struct can_frame buf_send[FLEXCAN_BUF_SEND_CAP];
+
+/* Структура для вызовов poll и select */
+	struct fasync_struct *async_queue;
+
+/* Очереди ожидания данных */
+	wait_queue_head_t inq, outq;
+
+/* Семафор */
+	struct semaphore sem;
+
+	// int (*do_set_bittiming)(__u8 *dev_num, struct can_bittiming *bittiming);
+	int (*do_set_mode)(__u8 *dev_num, enum can_mode mode);					// вернуть когда буду убирать netdevice
+	// int (*do_get_state)(__u8 *dev_num, enum can_state *state);
+	int (*do_get_berr_counter)(__u8 *dev_num, struct flexcan_stats *bec);
+};
+
+struct flexcan_device	{
+	char name[PLATFORM_NAME_SIZE];						
+	u8 is_init;					// флаг инициализации
+	dev_t f_devt;				// major номер группы
+
+	enum flexcan_ip_version version;
+
+	struct proc_dir_entry *dev_proc_dir;
+	struct class *f_class;	
+	struct flexcan_chardev f_dev[FLEXCAN_DEV_COUNT];
 };
 
+struct flexcan_devtype_data {
+	u32 features;	/* hardware controller features */
+};
+
+static struct flexcan_device fimx6d;
+
 static struct flexcan_devtype_data fsl_p1010_devtype_data = {
 	.features = FLEXCAN_HAS_BROKEN_ERR_STATE,
 };
@@ -240,83 +380,886 @@
 	.features = FLEXCAN_HAS_V10_FEATURES | FLEXCAN_HAS_ERR005829,
 };
 
-static const struct can_bittiming_const flexcan_bittiming_const = {
-	.name = DRV_NAME,
-	.tseg1_min = 4,
-	.tseg1_max = 16,
-	.tseg2_min = 2,
-	.tseg2_max = 8,
-	.sjw_max = 4,
-	.brp_min = 1,
-	.brp_max = 256,
-	.brp_inc = 1,
-};
+
+static unsigned int flexcan_start_transmit(const u8 dev_num);
+static void flexcan_set_bittiming(const u8 dev_num, const u32 reg_ctrl);
+static void flexcan_chip_stop(const u8 dev_num);
+static int flexcan_chip_start(const u8 dev_num);
+
+// ##########################################################################################################################################
 
 /*
- * Abstract off the read/write for arm versus ppc.
+ * Abstract off the read/write for arm versus ppc. This
+ * assumes that PPC uses big-endian registers and everything
+ * else uses little-endian registers, independent of CPU
+ * endianess.
  */
-#if defined(__BIG_ENDIAN)
+#if defined(CONFIG_PPC)
+
 static inline u32 flexcan_read(void __iomem *addr)
 {
 	return in_be32(addr);
 }
 
-static inline void flexcan_write(u32 val, void __iomem *addr)
+static inline void flexcan_write(u32 val, void __iomem *addr)
+{
+	out_be32(addr, val);
+}
+
+#else
+
+static inline u32 flexcan_read(void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static inline void flexcan_write(u32 val, void __iomem *addr)
+{
+	return writel(val, addr);
+}
+
+#endif
+
+static inline int flexcan_transceiver_enable(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+
+	if (!f_dev->reg_xceiver) {
+		return 0;
+	}
+
+	return regulator_enable(f_dev->reg_xceiver);
+}
+
+static inline int flexcan_transceiver_disable(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+
+	if (!f_dev->reg_xceiver) {
+		return 0;
+	}
+
+	return regulator_disable(f_dev->reg_xceiver);
+}
+
+// ##########################################################################################################################################
+
+static inline unsigned int flexcan_recv_buf_is_empty(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	return (f_dev->frame_buf_recv.n_push == f_dev->frame_buf_recv.n_pop);
+}
+
+
+static inline unsigned int flexcan_recv_buf_is_full(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	unsigned int n_next_first = (f_dev->frame_buf_recv.n_push + 1) & FLEXCAN_BUF_RECV_MASK;
+	return (n_next_first == f_dev->frame_buf_recv.n_pop);
+}
+
+
+static inline unsigned int flexcan_recv_buf_push(const u8 dev_num, const struct flexcan_mb *s_mb, const struct timeval *s_tv)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	circle_buf_t *f_buf = &f_dev->frame_buf_recv;
+
+	if(flexcan_recv_buf_is_full(dev_num)) {
+		return 1; 
+	}
+
+	struct flexcan_frame_mb *buf = (struct flexcan_frame_mb *) (f_dev->buf_recv + f_buf->n_push);
+	memcpy(&buf->mb, s_mb, sizeof(struct flexcan_mb));
+	memcpy(&buf->time, s_tv, sizeof(struct timeval));
+	f_buf->n_push = (f_buf->n_push + 1) & FLEXCAN_BUF_RECV_MASK;
+
+	return 0;
+}
+
+
+static inline unsigned int flexcan_recv_buf_pop(const u8 dev_num, struct flexcan_frame_mb *s_frame)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	circle_buf_t *f_buf = &f_dev->frame_buf_recv;
+
+	if(flexcan_recv_buf_is_empty(dev_num))	{
+		return 1;
+	}
+
+	*(struct flexcan_frame_mb *) s_frame = *(struct flexcan_frame_mb *) (f_dev->buf_recv + f_buf->n_pop);
+	f_buf->n_pop = (f_buf->n_pop + 1) & FLEXCAN_BUF_RECV_MASK;
+	f_buf->n_save_pop = f_buf->n_pop;
+	
+	return 0;
+}
+
+
+static inline unsigned int flexcan_recv_buf_get_free_space(const u8 dev_num)
+{
+	circle_buf_t *f_buf = &fimx6d.f_dev[dev_num].frame_buf_recv;
+	unsigned int buf_free_space = (f_buf->n_pop - f_buf->n_push - 1) & FLEXCAN_BUF_RECV_MASK;
+	return buf_free_space;
+}
+
+
+static inline unsigned int flexcan_recv_buf_get_data_size(const u8 dev_num)
+{
+	circle_buf_t *f_buf = &fimx6d.f_dev[dev_num].frame_buf_recv;
+	// unsigned int buf_data_size = (f_buf->n_push - f_buf->n_pop) & FLEXCAN_BUF_RECV_MASK;
+	unsigned int buf_data_size = (f_buf->n_push - f_buf->n_save_pop) & FLEXCAN_BUF_RECV_MASK;
+	return buf_data_size;
+}
+
+
+static inline unsigned int flexcan_recv_buf_end(const u8 dev_num)
+{
+	circle_buf_t *f_buf = &fimx6d.f_dev[dev_num].frame_buf_recv;
+	f_buf->n_pop = f_buf->n_push;
+	return 0;
+}
+
+
+static inline unsigned int flexcan_recv_buf_begin(const u8 dev_num)
+{
+	circle_buf_t *f_buf = &fimx6d.f_dev[dev_num].frame_buf_recv;
+	f_buf->n_pop = f_buf->n_save_pop;
+	return 0;
+}
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+static inline unsigned int flexcan_send_buf_is_empty(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	return (f_dev->frame_buf_send.n_push == f_dev->frame_buf_send.n_pop);
+}
+
+
+static inline unsigned int flexcan_send_buf_is_full(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	unsigned int n_next_first = (f_dev->frame_buf_send.n_push + 1) & FLEXCAN_BUF_SEND_MASK;
+	return (n_next_first == f_dev->frame_buf_send.n_pop);
+}
+
+
+static inline unsigned int flexcan_send_buf_push(const u8 dev_num, const struct can_frame *s_cf)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	circle_buf_t *f_buf = &f_dev->frame_buf_send;
+	unsigned int n_next_first = (f_buf->n_push + 1) & FLEXCAN_BUF_SEND_MASK;
+
+	if(flexcan_send_buf_is_full(dev_num)) 	{
+		return 1;
+	}
+
+	struct can_frame *buf = (struct can_frame *) (f_dev->buf_send + f_buf->n_push);
+	memcpy(buf, s_cf, sizeof(struct can_frame));
+	f_buf->n_push = n_next_first;
+
+	return 0;
+}
+
+
+static inline unsigned int flexcan_send_buf_pop(const u8 dev_num, struct can_frame *s_frame)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	circle_buf_t *f_buf = &f_dev->frame_buf_send;
+
+	if(flexcan_send_buf_is_empty(dev_num))	{
+		return 1;
+	}
+
+	*(struct can_frame *) s_frame = *(struct can_frame *) (f_dev->buf_send + f_buf->n_pop);
+	f_buf->n_pop = (f_buf->n_pop + 1) & FLEXCAN_BUF_SEND_MASK;
+
+	return 0;
+}
+
+
+static inline unsigned int flexcan_send_buf_free_space(const u8 dev_num)
+{
+	circle_buf_t *f_buf = &fimx6d.f_dev[dev_num].frame_buf_send;
+	unsigned int buf_free_space = (f_buf->n_pop - f_buf->n_push - 1) & FLEXCAN_BUF_SEND_MASK;
+	return buf_free_space;
+}
+
+
+static inline unsigned int flexcan_send_buf_data_size(const u8 dev_num)
+{
+	circle_buf_t *f_buf = &fimx6d.f_dev[dev_num].frame_buf_send;
+	unsigned int buf_data_size = (f_buf->n_push - f_buf->n_pop) & FLEXCAN_BUF_SEND_MASK;
+	return buf_data_size;
+}
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+static void flexcan_decode_frame(struct can_frame *cf, const struct flexcan_mb *mb)
+{
+	if (mb->can_ctrl & FLEXCAN_MB_CNT_IDE)	{
+		cf->can_id = ((mb->can_id >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;
+	}
+	else 	{
+		cf->can_id = (mb->can_id >> 18) & CAN_SFF_MASK;
+	}
+
+	if (mb->can_ctrl & FLEXCAN_MB_CNT_RTR)	{
+		cf->can_id |= CAN_RTR_FLAG;
+	}
+	cf->can_dlc = ((mb->can_ctrl >> 16) & 0xf);
+
+	if(cf->can_dlc == 0)	{
+		*(__be32 *)(cf->data + 0) = 0x00000000;
+		*(__be32 *)(cf->data + 4) = 0x00000000;
+	}
+	else if(cf->can_dlc <= 4)	{
+		*(__be32 *)(cf->data + 0) = cpu_to_be32(flexcan_read(&mb->data[0]));
+		*(__be32 *)(cf->data + 4) = 0x00000000;		
+	}
+	else 	{
+		*(__be32 *)(cf->data + 0) = cpu_to_be32(flexcan_read(&mb->data[0]));
+		*(__be32 *)(cf->data + 4) = cpu_to_be32(flexcan_read(&mb->data[1]));
+	}
+}
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+static int flexcan_char_fasync(int fd, struct file *filp, int mode)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	// printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+	return fasync_helper(fd, filp, mode, &fimx6d.f_dev[dev_num].async_queue);
+}
+
+
+static int flexcan_char_open(struct inode *i, struct file *filp)
+{
+	const u8 dev_num = iminor(i);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+
+	// printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+	if(down_interruptible(&f_dev->sem)) {
+		return -ERESTARTSYS;
+	}
+	if(filp->f_mode & FMODE_READ) {
+		f_dev->nreaders++;
+	}
+	if (filp->f_mode & FMODE_WRITE) {
+		f_dev->nwriters++;
+	}
+	up(&f_dev->sem);
+
+	dev_dbg(&f_dev->dev, "flexcan_char_open file open success\n");
+	
+	try_module_get(THIS_MODULE);
+	// return nonseekable_open(i, filp);	// если отключим llseek
+	return 0;
+}
+
+
+static int flexcan_char_release(struct inode *i, struct file *filp)
+{
+	const u8 dev_num = iminor(i);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+
+	// printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+	flexcan_char_fasync(-1, filp, 0);
+	down(&f_dev->sem);
+	if (filp->f_mode & FMODE_READ) {
+		f_dev->nreaders--;
+	}
+	if (filp->f_mode & FMODE_WRITE) {
+		f_dev->nwriters--;
+	}
+	up(&f_dev->sem);
+
+	module_put(THIS_MODULE);
+    return 0;
+}
+
+
+static loff_t flexcan_char_llseek(struct file *filp, loff_t off, int whence)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+    loff_t newpos = 0;
+
+    // printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+    switch(whence) {
+		case 0: /* SEEK_SET */
+			// printk("%s.%d: %s SEEK_SET filp->f_pos = %d, off = %d\n", fimx6d.name, (int) dev_num, __func__, filp->f_pos, off);
+			flexcan_recv_buf_begin(dev_num);
+			newpos = 0;	/* Всегда в начало */
+			break;
+		case 1: /* SEEK_CUR */
+			// printk("%s.%d: %s SEEK_CUR filp->f_pos = %d, off = %d\n", fimx6d.name, (int) dev_num, __func__, filp->f_pos, off);
+			newpos = flexcan_recv_buf_get_data_size(dev_num) * CAN_DATA_MSG_LENGTH;
+			break;
+		case 2: /* SEEK_END */
+			// printk("%s.%d: %s SEEK_END filp->f_pos = %d, off = %d\n", fimx6d.name, (int) dev_num, __func__, filp->f_pos, off);
+			flexcan_recv_buf_end(dev_num);
+			newpos = flexcan_recv_buf_get_data_size(dev_num) * CAN_DATA_MSG_LENGTH;
+			break;
+		default: /* не может произойти */
+			return -EINVAL;
+    }
+
+    if(newpos < 0) {
+    	return -EINVAL;
+    }
+    filp->f_pos = newpos;
+    return newpos;
+}
+
+
+static unsigned int flexcan_char_poll(struct file *filp, poll_table *wait)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	unsigned int mask = 0;
+
+	// printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+	down(&f_dev->sem);
+	poll_wait(filp, &f_dev->inq,  wait);
+	poll_wait(filp, &f_dev->outq, wait);
+	if(flexcan_recv_buf_get_data_size(dev_num)) {
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+	}
+	if(flexcan_send_buf_is_full(dev_num) == 0) {
+		mask |= POLLOUT | POLLWRNORM;	/* writable */
+	}
+	up(&f_dev->sem);
+
+	return mask;
+}
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+static ssize_t flexcan_char_read(struct file *filp, char __user *buf, size_t length_read, loff_t *off)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_frame_mb read_frame;
+	struct can_frame cf_decoded;
+	ssize_t total_length = 0;
+	char data_msg_buf[CAN_DATA_MSG_LENGTH + 1];
+	u64 msg_data = 0;
+	int ret = 0;
+
+	// printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+	if(length_read < CAN_DATA_MSG_LENGTH) {	/* Проверяем размер буффера пользователя */
+		dev_dbg(&f_dev->dev, "flexcan_char_read return EFAULT\n");
+		return -EINVAL;
+	}
+	if (down_interruptible(&f_dev->sem)) {
+		return -ERESTARTSYS;	
+	}
+
+	while(flexcan_recv_buf_is_empty(dev_num)) {	/* Проверяем пустой ли буффер */
+		up(&f_dev->sem); /* release the lock */
+		if (filp->f_flags & O_NONBLOCK) {	/* если вызов не блокирующий, вываливаемся */
+			dev_dbg(&f_dev->dev, "flexcan_char_read return EAGAIN\n");
+			return -EAGAIN;
+		}
+		if (wait_event_interruptible(f_dev->inq, !flexcan_recv_buf_is_empty(dev_num))) {
+			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		}
+		if (down_interruptible(&f_dev->sem)) {
+			return -ERESTARTSYS;
+		}
+	}
+
+	do {
+		if(flexcan_recv_buf_pop(dev_num, &read_frame)) {
+			dev_dbg(&f_dev->dev, "flexcan_char_read read err\n");
+			break;
+		}
+		
+		msg_data = 0;
+		flexcan_decode_frame(&cf_decoded, &read_frame.mb);
+		memcpy((void*) &msg_data, (void*) cf_decoded.data, cf_decoded.can_dlc);
+
+		ret = snprintf(data_msg_buf, (CAN_DATA_MSG_LENGTH + 1), "$CAN,%d,%08x,%05x,%08x,%d,%016llx\n", dev_num, (unsigned int) read_frame.time.tv_sec, 
+			(unsigned int) read_frame.time.tv_usec, cf_decoded.can_id, cf_decoded.can_dlc, msg_data);
+		if(ret != CAN_DATA_MSG_LENGTH) {
+			dev_dbg(&f_dev->dev, "flexcan_char_read error size: need[%d], ret[%d]\n", CAN_DATA_MSG_LENGTH, ret);
+			// printk("%s.%d: %s error size: need[%d], ret[%d]\n", fimx6d.name, dev_num, __func__, msg_length, ret);
+			continue;
+		}
+
+		// printk("%s.%d: %s copy_to_user %s\n", fimx6d.name, dev_num, __func__, data_msg_buf);
+		ret = copy_to_user((void *) buf, &data_msg_buf, CAN_DATA_MSG_LENGTH);	
+		if(ret)	{
+			dev_dbg(&f_dev->dev, "flexcan_char_read can't copy = %d bytes\n", ret);
+			// printk("flexcan_char_read can't copy = %d bytes\n", ret);
+			buf += (CAN_DATA_MSG_LENGTH - ret);
+			total_length += (CAN_DATA_MSG_LENGTH - ret);
+			break;
+		}
+		else {
+			buf += CAN_DATA_MSG_LENGTH;
+			total_length += CAN_DATA_MSG_LENGTH;
+		}
+	} while(((total_length + CAN_DATA_MSG_LENGTH) <= length_read) && (flexcan_recv_buf_is_empty(dev_num) == 0));
+
+	up (&f_dev->sem);
+	wake_up_interruptible(&f_dev->outq);
+
+	return total_length;
+}
+
+
+static ssize_t flexcan_char_write(struct file *filp, const char __user *buf, size_t length, loff_t *off)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct can_frame* user_buf_ptr = (struct can_frame *) buf;
+	struct can_frame cf;
+	int ret = 0, to_read = 0, was_read = 0;;
+
+	// printk("%s.%d: %s\n", fimx6d.name, (int) dev_num, __func__);
+	if(length < sizeof(struct can_frame)) { /* Проверяем размер сообщения */
+		dev_dbg(&f_dev->dev, "flexcan_char_write return -EFAULT\n");
+		return -EINVAL;
+	}
+	to_read = (((int) length) / sizeof(struct can_frame));
+
+	if(down_interruptible(&f_dev->sem)) {
+		return -ERESTARTSYS;
+	}
+
+	while(flexcan_send_buf_is_full(dev_num)) {	/* Проверяем наличие данных в буфере */
+		flexcan_start_transmit(dev_num);
+
+		DEFINE_WAIT(wait);
+		up(&f_dev->sem);
+		if (filp->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		prepare_to_wait(&f_dev->outq, &wait, TASK_INTERRUPTIBLE);
+		finish_wait(&f_dev->outq, &wait);
+		if (signal_pending(current)) {
+			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		}
+		if (down_interruptible(&f_dev->sem)) {
+			return -ERESTARTSYS;
+		}
+	}
+
+	do {	/* Получение данных */
+		ret = copy_from_user(&cf, user_buf_ptr++, sizeof(struct can_frame));
+		if(ret) {
+			dev_dbg(&f_dev->dev, "flexcan_char_write can't copy = %d bytes\n", ret);
+			// printk("%s.%d: %s copy_from_user can't copy = %d bytes\n", fimx6d.name, (int) dev_num, __func__, ret);
+		}
+		else {
+			dev_dbg(&f_dev->dev, "flexcan_char_write frame: 0x%08x, %d, 0x%llx\n", cf.can_id, cf.can_dlc, (long long unsigned int) cf.data[0]);
+			if(cf.can_dlc <= 8) {
+				if(flexcan_send_buf_push(dev_num, &cf)) {
+					dev_dbg(&f_dev->dev, "flexcan_char_write buffer drop frame\n");
+					// printk("%s.%d: %s buffer drop frame\n", fimx6d.name, (int) dev_num, __func__);
+					break;
+				}
+			flexcan_start_transmit(dev_num);
+			}
+			else {
+				dev_dbg(&f_dev->dev, "flexcan_char_write BAD frame\n");
+				// printk("%s.%d: %s BAD frame\n", fimx6d.name, (int) dev_num, __func__);
+			}
+			was_read++;
+			to_read--;
+		}
+	} while((to_read > 0) && (ret == 0));
+
+	if(flexcan_send_buf_data_size(dev_num)) {
+		flexcan_start_transmit(dev_num);
+	}
+
+	up(&f_dev->sem);
+	wake_up_interruptible(&f_dev->inq);  /* blocked in read() and select() */
+	if(f_dev->async_queue) {	/* and signal asynchronous readers, explained late in chapter 5 */
+		kill_fasync(&f_dev->async_queue, SIGIO, POLL_IN);
+	}
+
+    return (was_read * sizeof(struct can_frame));
+}
+
+
+static long flexcan_char_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
+{	
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	u32 read_settings = 0, set_mode = 0, set_bitrate = 0;
+	static u32 set_reg_ctrl = 0;
+
+	dev_dbg(&f_dev->dev, "flexcan_char_ioctl IOCTL request\n");
+	switch (ioctl_num) {
+		case FLEXCAN_IOCTL_READ:
+			put_user(read_settings, (int *) ioctl_param);
+			break;
+		case FLEXCAN_IOCTL_WRITE:
+			get_user(read_settings, (int *) ioctl_param);
+
+			set_mode = read_settings & SET_CAN_MODE_MASK;
+			set_bitrate = read_settings & SET_CAN_BITRATE_MASK;
+
+			if(set_bitrate || set_mode) {
+				switch (set_bitrate) {
+					case SET_CAN_BITRATE_1000:
+						set_reg_ctrl = FLEXCAN_BTRT_1000;
+						printk("%s.%d: %s set bitrate 1000000\n", fimx6d.name, dev_num, __func__);
+						break;
+					case SET_CAN_BITRATE_500:
+						set_reg_ctrl = FLEXCAN_BTRT_500;
+						printk("%s.%d: %s set bitrate 500000\n", fimx6d.name, dev_num, __func__);
+						break;
+					case SET_CAN_BITRATE_250:
+						set_reg_ctrl = FLEXCAN_BTRT_250;
+						printk("%s.%d: %s set bitrate 250000\n", fimx6d.name, dev_num, __func__);
+						break;
+					case SET_CAN_BITRATE_125:
+						set_reg_ctrl = FLEXCAN_BTRT_125;
+						printk("%s.%d: %s set bitrate 125000\n", fimx6d.name, dev_num, __func__);
+						break;
+					case SET_CAN_BITRATE_100:
+						set_reg_ctrl = FLEXCAN_BTRT_100;
+						printk("%s.%d: %s set bitrate 100000\n", fimx6d.name, dev_num, __func__);
+						break;
+				}
+				if (set_mode & SET_CAN_MODE_LOOPBACK) {
+					set_reg_ctrl |= FLEXCAN_CTRL_LPB;
+				}
+				if (set_mode & SET_CAN_MODE_LISTENONLY) {
+					set_reg_ctrl |= FLEXCAN_CTRL_LOM;
+				}
+				if (set_mode & SET_CAN_MODE_3_SAMPLES) {
+					set_reg_ctrl |= FLEXCAN_CTRL_SMP;
+				}
+
+				if(f_dev->reg_ctrl_bittiming != set_reg_ctrl) {
+					// printk("%s.%d: %s need restart module\n", fimx6d.name, dev_num, __func__);
+					f_dev->reg_ctrl_bittiming = set_reg_ctrl;
+
+					up (&f_dev->sem);	// возможно с семафором тут лишнее
+					if (down_interruptible(&f_dev->sem)) {
+						return -ERESTARTSYS;
+					}
+					flexcan_chip_stop(dev_num);
+					if(flexcan_chip_start(dev_num)) {
+						dev_dbg(&f_dev->dev, "flexcan_char_ioctl error when try to start the module\n");
+					}
+					up (&f_dev->sem);
+				}
+			}
+			// тут вызвать функцию которая задаст новые настройки для конкретного can интерфейса
+			// возможно нужно самому написать эту функцию, переписав flexcan_set_bittiming() или не нужно, еще не проверял.
+			break;
+		case FLEXCAN_IOCTL_WR_RD:
+			return -EINVAL;	// будет не поддерживаемая инструкция пока не придумаю зачем она надо
+			break;
+		default:
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+static struct file_operations flexcan_fops =
+{
+    .owner = THIS_MODULE,
+    .llseek = flexcan_char_llseek,
+    .read = flexcan_char_read,
+    .write = flexcan_char_write,
+    .poll = flexcan_char_poll,
+    .open = flexcan_char_open,
+    .release = flexcan_char_release,
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+    	.ioctl = flexcan_char_ioctl,
+	#else
+    	.unlocked_ioctl = flexcan_char_ioctl,
+	#endif
+    .fasync = flexcan_char_fasync,
+};
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+static inline void flexcan_f_dev_init(struct flexcan_chardev *f_dev)
+{
+	f_dev->stats.rx_frames = 0;
+	f_dev->stats.tx_frames = 0;
+	f_dev->stats.rx_bytes = 0;
+	f_dev->stats.tx_bytes = 0;	
+
+	f_dev->stats.int_wak = 0;
+	f_dev->stats.int_state = 0;
+	f_dev->stats.int_rx_frame = 0;
+	f_dev->stats.int_tx_frame = 0;
+	f_dev->stats.int_num = 0;
+
+	f_dev->stats.err_tx = 0;
+	f_dev->stats.err_rx = 0;
+	f_dev->stats.err_over = 0;
+	f_dev->stats.err_warn = 0;
+	f_dev->stats.err_frame = 0;	
+	f_dev->stats.err_drop = 0;
+	f_dev->stats.err_length = 0;
+	f_dev->stats.err_fifo = 0;
+
+	f_dev->stats.reg_esr = 0;	
+	f_dev->stats.reg_mcr = 0;	
+	f_dev->stats.reg_ctrl = 0;
+
+	f_dev->buf_recv_size = FLEXCAN_BUF_RECV_CAP;
+	f_dev->frame_buf_recv.n_push = 0;
+	f_dev->frame_buf_recv.n_save_pop = 0;
+	f_dev->frame_buf_recv.n_pop = 0;
+
+	f_dev->buf_send_size = FLEXCAN_BUF_SEND_CAP;
+	f_dev->frame_buf_send.n_push = 0;
+	f_dev->frame_buf_send.n_save_pop = 0;
+	f_dev->frame_buf_send.n_pop = 0;
+
+	f_dev->reg_ctrl_bittiming = FLEXCAN_BTRT_DFLT;
+
+	init_waitqueue_head(&(f_dev->inq));
+	init_waitqueue_head(&(f_dev->outq));
+	init_MUTEX(&f_dev->sem);
+}
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+#ifdef FLEXCAN_USE_PROC_FS
+
+#define NAME_DIR "flexcan"
+#define LEN_MSG (3072)
+#define MAX_DIGITS (10)
+
+static char *get_rw_buf(const u8 dev_num, int *length) 
+{
+	struct flexcan_stats *stats = &fimx6d.f_dev[dev_num].stats;
+	static char buf_msg[LEN_MSG + 1];
+	char *buf_ptr = buf_msg;
+	int buf_length = 0;
+
+	memset(buf_msg, 0, (LEN_MSG + 1));
+
+	snprintf(buf_ptr, (30 + 1), "Data communication statistic:\n");
+	buf_ptr += 30;
+	buf_length += 30;
+	snprintf(buf_ptr, (22 + MAX_DIGITS + 1), "\tReceived frames   = %d\n", (int) stats->rx_frames);	// количество принятых фреймов
+	buf_ptr += (22 + MAX_DIGITS);
+	buf_length += (22 + MAX_DIGITS);
+	snprintf(buf_ptr, (22 + MAX_DIGITS + 1), "\tTransmited frames = %d\n", (int) stats->tx_frames);	// количество отправленных фреймов
+	buf_ptr += (22 + MAX_DIGITS);
+	buf_length += (22 + MAX_DIGITS);
+	snprintf(buf_ptr, (22 + MAX_DIGITS + 1), "\tReceived bytes    = %d\n", (int) stats->rx_bytes);	// количество принятых байт данных
+	buf_ptr += (22 + MAX_DIGITS);
+	buf_length += (22 + MAX_DIGITS);
+	snprintf(buf_ptr, (22 + MAX_DIGITS + 1), "\tTransmited bytes  = %d\n", (int) stats->tx_bytes);	// количество отправленных байт данных
+	buf_ptr += (22 + MAX_DIGITS);
+	buf_length += (22 + MAX_DIGITS);
+
+	snprintf(buf_ptr, (23 + 1), "\nInterrupts statistic:\n");
+	buf_ptr += 23;
+	buf_length += 23;	
+	snprintf(buf_ptr, (21 + MAX_DIGITS + 1), "\tWakeUp           = %d\n", (int) stats->int_wak);	// количество прерываний пробуждения
+	buf_ptr += (21 + MAX_DIGITS);
+	buf_length += (21 + MAX_DIGITS);
+	snprintf(buf_ptr, (21 + MAX_DIGITS + 1), "\tState change     = %d\n", (int) stats->int_state);	// количество прерываний проверки состояния
+	buf_ptr += (21 + MAX_DIGITS);
+	buf_length += (21 + MAX_DIGITS);
+	snprintf(buf_ptr, (21 + MAX_DIGITS + 1), "\tRead frame       = %d\n", (int) stats->int_rx_frame);	// количество прерываний чтения фреймов
+	buf_ptr += (21 + MAX_DIGITS);
+	buf_length += (21 + MAX_DIGITS);
+	snprintf(buf_ptr, (21 + MAX_DIGITS + 1), "\tTransmit frame   = %d\n", (int) stats->int_tx_frame);	// количество прерываний отправки фреймов
+	buf_ptr += (21 + MAX_DIGITS);
+	buf_length += (21 + MAX_DIGITS);
+	snprintf(buf_ptr, (21 + MAX_DIGITS + 1), "\tTotal interrupts = %d\n", (int) stats->int_num);	// количество прерываний
+	buf_ptr += (21 + MAX_DIGITS);
+	buf_length += (21 + MAX_DIGITS);
+
+	snprintf(buf_ptr, (19 + 1), "\nErrors statistic:\n");
+	buf_ptr += 19;
+	buf_length += 19;
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tTransmit = %d\n", (int) stats->err_tx);	// количество ошибок отправки фреймов
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tReceive  = %d\n", (int) stats->err_rx);	// количество ошибок принятия фреймов
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tOverflow = %d\n", (int) stats->err_over);	// количество переполнений буффера
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tWarning  = %d\n", (int) stats->err_warn);	// количество заполнений буффера
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tFrame    = %d\n", (int) stats->err_frame);	// количество ошибочных фреймов
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tDroped   = %d\n", (int) stats->err_drop);	// количество потерянных при чтении фреймов
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tLength   = %d\n", (int) stats->err_length);	// количество ошибок длины фреймов
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\tFIFO     = %d\n", (int) stats->err_fifo);	// количество ошибок fifo буффера
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+
+	snprintf(buf_ptr, (18 + 1), "\nRegisters state:\n");
+	buf_ptr += 18;
+	buf_length += 18;
+	snprintf(buf_ptr, (11 + MAX_DIGITS + 1), "\tESR  = %#08x\n", (int) stats->reg_esr);	// состояние регистра esr
+	buf_ptr += (11 + MAX_DIGITS);
+	buf_length += (11 + MAX_DIGITS);
+	snprintf(buf_ptr, (11 + MAX_DIGITS + 1), "\tMCR  = %#08x\n", (int) stats->reg_mcr);	// состояние регистра mcr
+	buf_ptr += (11 + MAX_DIGITS);
+	buf_length += (11 + MAX_DIGITS);
+	snprintf(buf_ptr, (11 + MAX_DIGITS + 1), "\tCTRL = %#08x\n", (int) stats->reg_ctrl);	// состояние регистра ctrl
+	buf_ptr += (11 + MAX_DIGITS);
+	buf_length += (11 + MAX_DIGITS);
+
+	snprintf(buf_ptr, (13 + MAX_DIGITS + 1), "\nFrequency = %d\n", (int) stats->freq);	// частота модуля
+	buf_ptr += (13 + MAX_DIGITS);
+	buf_length += (13 + MAX_DIGITS);
+
+	*length = buf_length;
+
+	return buf_msg;
+}
+
+#endif
+
+// ##########################################################################################################################################
+// ##########################################################################################################################################
+
+#ifdef FLEXCAN_USE_PROC_FS
+
+static ssize_t flexcan_proc_read(struct file *filp, char *buf, size_t count, loff_t *ppos) // чтение из /proc/*my_dir*/*my_node* :
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	const u8 dev_num = iminor(inode);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	int buf_length = 0, ret = 0;
+
+	char *buf_msg = get_rw_buf(dev_num, &buf_length);
+
+	if(*ppos >= buf_length) 	{
+		dev_dbg(&f_dev->dev, "%s.%d: %s eof\n", fimx6d.name, dev_num, __func__);
+		return 0;
+	}
+
+	ret = copy_to_user((void*)buf, buf_msg + *ppos, buf_length);
+	*ppos += (buf_length - ret);
+
+	return (buf_length - ret);
+}
+
+
+static const struct file_operations flexcan_proc_fops = {
+   .owner = THIS_MODULE,
+   .read  = flexcan_proc_read,
+};
+
+
+static int flexcan_proc_dir_init(const u8 dev_num) 
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	int ret;
+
+	fimx6d.dev_proc_dir = create_proc_entry(NAME_DIR, S_IFDIR | S_IRWXUGO, NULL);
+	if(NULL == fimx6d.dev_proc_dir) {
+		ret = -ENOENT;
+		dev_dbg(&f_dev->dev, "flexcan_proc_dir_init can't create directory /proc/%s\n", NAME_DIR);
+		goto err_dir;
+	}
+
+	fimx6d.dev_proc_dir->uid = 0;
+	fimx6d.dev_proc_dir->gid = 0;
+
+	return 0;
+
+ err_dir:
+	return ret;
+}
+
+
+static int flexcan_proc_file_init(const u8 dev_num) 
 {
-	out_be32(addr, val);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	int ret;
+
+	f_dev->dev_proc_file = create_proc_entry(f_dev->name, (S_IFREG | S_IRUGO), fimx6d.dev_proc_dir);
+	if(NULL == f_dev->dev_proc_file) {
+		ret = -ENOENT;
+		dev_dbg(&f_dev->dev, "flexcan_proc_file_init can't create node /proc/%s/%s\n", NAME_DIR, f_dev->name);
+		goto err_file;
+	}
+
+	f_dev->dev_proc_file->uid = 0;
+	f_dev->dev_proc_file->gid = 0;
+	f_dev->dev_proc_file->proc_fops = &flexcan_proc_fops;
+
+	return 0;
+
+ err_file:
+	return ret;
 }
-#else
-static inline u32 flexcan_read(void __iomem *addr)
+
+
+static void flexcan_proc_file_exit(const u8 dev_num) 
 {
-	return readl(addr);
+	remove_proc_entry(fimx6d.f_dev[dev_num].name, fimx6d.dev_proc_dir);
 }
 
-static inline void flexcan_write(u32 val, void __iomem *addr)
+
+static void flexcan_proc_dir_exit(void) 
 {
-	writel(val, addr);
+	remove_proc_entry(NAME_DIR, NULL);
 }
+
 #endif
 
-static inline void flexcan_enter_stop_mode(struct flexcan_priv *priv)
-{
-	/* enable stop request */
-	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES)
-		regmap_update_bits(priv->stm.gpr, priv->stm.req_gpr,
-			1 << priv->stm.req_bit, 1 << priv->stm.req_bit);
-}
+// ##########################################################################################################################################
+// ##########################################################################################################################################
 
-static inline void flexcan_exit_stop_mode(struct flexcan_priv *priv)
-{
-	/* remove stop request */
-	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES)
-		regmap_update_bits(priv->stm.gpr, priv->stm.req_gpr,
-			1 << priv->stm.req_bit, 0);
-}
+// static void flexcan_transceiver_switch(const struct flexcan_platform_data *pdata, int on)
+// {
+// 	if (pdata && pdata->transceiver_switch) {
+// 		pdata->transceiver_switch(on);
+// 	}
+// }
 
-/*
- * Swtich transceiver on or off
- */
-static void flexcan_transceiver_switch(const struct flexcan_priv *priv, int on)
-{
-	if (priv->pdata && priv->pdata->transceiver_switch)
-		priv->pdata->transceiver_switch(on);
-	else if (gpio_is_valid(priv->stby_gpio)) {
-		if (priv->stby_gpio_flags & OF_GPIO_ACTIVE_LOW)
-			on = !on ;
-		gpio_set_value(priv->stby_gpio, on);
-	}
-}
+// static void flexcan_gpio_switch(const struct flexcan_platform_data *pdata, int on)
+// {
+// 	if (pdata && pdata->gpio_switch) {
+// 		pdata->gpio_switch(on);
+// 	}
+// }
 
-static inline int flexcan_has_and_handle_berr(const struct flexcan_priv *priv,
-					      u32 reg_esr)
+static inline int flexcan_has_and_handle_berr(const struct flexcan_stats *stats, u32 reg_esr)
 {
-	return (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&
-		(reg_esr & FLEXCAN_ESR_ERR_BUS);
+	return (stats->ctrlmode & CAN_CTRLMODE_BERR_REPORTING) && (reg_esr & FLEXCAN_ESR_ERR_BUS);
 }
 
-static inline void flexcan_chip_enable(struct flexcan_priv *priv)
+static inline void flexcan_chip_enable(void __iomem *base)
 {
-	struct flexcan_regs __iomem *regs = priv->base;
+	struct flexcan_regs __iomem *regs = base;
 	u32 reg;
 
 	reg = flexcan_read(&regs->mcr);
@@ -326,9 +1269,9 @@
 	udelay(10);
 }
 
-static inline void flexcan_chip_disable(struct flexcan_priv *priv)
+static inline void flexcan_chip_disable(void __iomem *base)
 {
-	struct flexcan_regs __iomem *regs = priv->base;
+	struct flexcan_regs __iomem *regs = base;
 	u32 reg;
 
 	reg = flexcan_read(&regs->mcr);
@@ -336,11 +1279,9 @@
 	flexcan_write(reg, &regs->mcr);
 }
 
-static int flexcan_get_berr_counter(const struct net_device *dev,
-				    struct can_berr_counter *bec)
+static int flexcan_get_berr_counter(__u8 dev_num, struct can_berr_counter *bec)
 {
-	const struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
+	struct flexcan_regs __iomem *regs = fimx6d.f_dev[dev_num].f_base;
 	u32 reg = flexcan_read(&regs->ecr);
 
 	bec->txerr = (reg >> 0) & 0xff;
@@ -349,619 +1290,550 @@
 	return 0;
 }
 
-static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static unsigned int flexcan_start_transmit(const u8 dev_num)
 {
-	const struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
-	struct can_frame *cf = (struct can_frame *)skb->data;
-	u32 can_id;
-	u32 ctrl = FLEXCAN_MB_CNT_CODE(0xc) | (cf->can_dlc << 16);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
+	struct flexcan_stats *stats = &f_dev->stats;
+	struct can_frame cf;
+	u32 can_id, ctrl, data;
 
-	if (can_dropped_invalid_skb(dev, skb))
-		return NETDEV_TX_OK;
+	/* На будущее проверка статуса буфера в данный момент */
+	// u8 mb_code = ((flexcan_read(&regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl) >> 24) & 0x0F);
 
-	netif_stop_queue(dev);
+	if(flexcan_send_buf_pop(dev_num, &cf) != 0) {
+		dev_dbg(&f_dev->dev, "flexcan_start_transmit buffer free\n");
+		return 0;
+	}
 
-	if (cf->can_id & CAN_EFF_FLAG) {
-		can_id = cf->can_id & CAN_EFF_MASK;
+	dev_dbg(&f_dev->dev, "flexcan_start_transmit send messages\n");
+	ctrl = FLEXCAN_MB_CNT_CODE(0xc) | (cf.can_dlc << 16);
+	if (cf.can_id & CAN_EFF_FLAG) {
+		can_id = cf.can_id & CAN_EFF_MASK;
 		ctrl |= FLEXCAN_MB_CNT_IDE | FLEXCAN_MB_CNT_SRR;
-	} else {
-		can_id = (cf->can_id & CAN_SFF_MASK) << 18;
+	} 
+	else {
+		can_id = (cf.can_id & CAN_SFF_MASK) << 18;
 	}
 
-	if (cf->can_id & CAN_RTR_FLAG)
+	if (cf.can_id & CAN_RTR_FLAG) {
 		ctrl |= FLEXCAN_MB_CNT_RTR;
+	}
 
-	if (cf->can_dlc > 0) {
-		u32 data = be32_to_cpup((__be32 *)&cf->data[0]);
+	if (cf.can_dlc > 0) {
+		data = be32_to_cpup((__be32 *)&cf.data[0]);
 		flexcan_write(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[0]);
-	}
-	if (cf->can_dlc > 3) {
-		u32 data = be32_to_cpup((__be32 *)&cf->data[4]);
+	}	
+	if (cf.can_dlc > 3) {
+		data = be32_to_cpup((__be32 *)&cf.data[4]);
 		flexcan_write(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[1]);
 	}
 
-	can_put_echo_skb(skb, dev, 0);
-
 	flexcan_write(can_id, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_id);
 	flexcan_write(ctrl, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);
+	/* tx_packets is incremented in flexcan_irq */
+	stats->tx_bytes += cf.can_dlc;
 
-	if (priv->devtype_data->features & FLEXCAN_HAS_ERR005829) {
-		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
-		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
-	}
-
-	return NETDEV_TX_OK;
+	return 0;
 }
 
-static void do_bus_err(struct net_device *dev,
-		       struct can_frame *cf, u32 reg_esr)
+static void do_bus_err(struct can_frame *cf, u32 reg_esr, const u8 dev_num)
 {
-	struct flexcan_priv *priv = netdev_priv(dev);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_stats *stats = &f_dev->stats;
 	int rx_errors = 0, tx_errors = 0;
 
 	cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
-
 	if (reg_esr & FLEXCAN_ESR_BIT1_ERR) {
-		netdev_dbg(dev, "BIT1_ERR irq\n");
+		dev_dbg(&f_dev->dev, "BIT1_ERR irq\n");
 		cf->data[2] |= CAN_ERR_PROT_BIT1;
 		tx_errors = 1;
 	}
 	if (reg_esr & FLEXCAN_ESR_BIT0_ERR) {
-		netdev_dbg(dev, "BIT0_ERR irq\n");
+		dev_dbg(&f_dev->dev, "BIT0_ERR irq\n");
 		cf->data[2] |= CAN_ERR_PROT_BIT0;
 		tx_errors = 1;
 	}
 	if (reg_esr & FLEXCAN_ESR_ACK_ERR) {
-		netdev_dbg(dev, "ACK_ERR irq\n");
+		dev_dbg(&f_dev->dev, "ACK_ERR irq\n");
 		cf->can_id |= CAN_ERR_ACK;
 		cf->data[3] |= CAN_ERR_PROT_LOC_ACK;
 		tx_errors = 1;
 	}
 	if (reg_esr & FLEXCAN_ESR_CRC_ERR) {
-		netdev_dbg(dev, "CRC_ERR irq\n");
+		dev_dbg(&f_dev->dev, "CRC_ERR irq\n");
 		cf->data[2] |= CAN_ERR_PROT_BIT;
 		cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
 		rx_errors = 1;
 	}
 	if (reg_esr & FLEXCAN_ESR_FRM_ERR) {
-		netdev_dbg(dev, "FRM_ERR irq\n");
+		dev_dbg(&f_dev->dev, "FRM_ERR irq\n");
 		cf->data[2] |= CAN_ERR_PROT_FORM;
 		rx_errors = 1;
 	}
 	if (reg_esr & FLEXCAN_ESR_STF_ERR) {
-		netdev_dbg(dev, "STF_ERR irq\n");
+		dev_dbg(&f_dev->dev, "STF_ERR irq\n");
 		cf->data[2] |= CAN_ERR_PROT_STUFF;
 		rx_errors = 1;
 	}
 
-	priv->can.can_stats.bus_error++;
-	if (rx_errors)
-		dev->stats.rx_errors++;
-	if (tx_errors)
-		dev->stats.tx_errors++;
-}
-
-static int flexcan_poll_bus_err(struct net_device *dev, u32 reg_esr)
-{
-	struct sk_buff *skb;
-	struct can_frame *cf;
-
-	skb = alloc_can_err_skb(dev, &cf);
-	if (unlikely(!skb))
-		return 0;
-
-	do_bus_err(dev, cf, reg_esr);
-	netif_receive_skb(skb);
-
-	dev->stats.rx_packets++;
-	dev->stats.rx_bytes += cf->can_dlc;
-
-	return 1;
+	stats->dev_stats.bus_error++;
+	if (rx_errors)	{
+		stats->err_rx++;
+	}
+	if (tx_errors)	{
+		stats->err_tx++;
+	}
 }
 
-static void do_state(struct net_device *dev,
-		     struct can_frame *cf, enum can_state new_state)
+static void do_state(struct can_frame *cf, const u8 dev_num, enum can_state new_state)
 {
-	struct flexcan_priv *priv = netdev_priv(dev);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_stats *stats = &f_dev->stats;
 	struct can_berr_counter bec;
 
-	flexcan_get_berr_counter(dev, &bec);
+	dev_dbg(&f_dev->dev, "do_state get berr counter\n");
+	flexcan_get_berr_counter(dev_num, &bec);
 
-	switch (priv->can.state) {
-	case CAN_STATE_ERROR_ACTIVE:
-		/*
-		 * from: ERROR_ACTIVE
-		 * to  : ERROR_WARNING, ERROR_PASSIVE, BUS_OFF
-		 * =>  : there was a warning int
-		 */
-		if (new_state >= CAN_STATE_ERROR_WARNING &&
-		    new_state <= CAN_STATE_BUS_OFF) {
-			netdev_dbg(dev, "Error Warning IRQ\n");
-			priv->can.can_stats.error_warning++;
-
-			cf->can_id |= CAN_ERR_CRTL;
-			cf->data[1] = (bec.txerr > bec.rxerr) ?
-				CAN_ERR_CRTL_TX_WARNING :
-				CAN_ERR_CRTL_RX_WARNING;
-		}
-	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
-		/*
-		 * from: ERROR_ACTIVE, ERROR_WARNING
-		 * to  : ERROR_PASSIVE, BUS_OFF
-		 * =>  : error passive int
-		 */
-		if (new_state >= CAN_STATE_ERROR_PASSIVE &&
-		    new_state <= CAN_STATE_BUS_OFF) {
-			netdev_dbg(dev, "Error Passive IRQ\n");
-			priv->can.can_stats.error_passive++;
-
-			cf->can_id |= CAN_ERR_CRTL;
-			cf->data[1] = (bec.txerr > bec.rxerr) ?
-				CAN_ERR_CRTL_TX_PASSIVE :
-				CAN_ERR_CRTL_RX_PASSIVE;
-		}
-		break;
-	case CAN_STATE_BUS_OFF:
-		netdev_err(dev, "BUG! "
-			   "hardware recovered automatically from BUS_OFF\n");
-		break;
-	default:
-		break;
+	switch (stats->state) {
+		case CAN_STATE_ERROR_ACTIVE:
+			/*
+			 * from: ERROR_ACTIVE
+			 * to  : ERROR_WARNING, ERROR_PASSIVE, BUS_OFF
+			 * =>  : there was a warning int
+			 */
+			if (new_state >= CAN_STATE_ERROR_WARNING &&
+			    new_state <= CAN_STATE_BUS_OFF) {
+				dev_dbg(&f_dev->dev, "do_state Error Warning IRQ\n");
+				stats->dev_stats.error_warning++;
+
+				cf->can_id |= CAN_ERR_CRTL;
+				cf->data[1] = (bec.txerr > bec.rxerr) ? CAN_ERR_CRTL_TX_WARNING : CAN_ERR_CRTL_RX_WARNING;
+			}
+		case CAN_STATE_ERROR_WARNING:	/* fallthrough */
+			/*
+			 * from: ERROR_ACTIVE, ERROR_WARNING
+			 * to  : ERROR_PASSIVE, BUS_OFF
+			 * =>  : error passive int
+			 */
+			if (new_state >= CAN_STATE_ERROR_PASSIVE &&
+			    new_state <= CAN_STATE_BUS_OFF) {
+				dev_dbg(&f_dev->dev, "do_state Error Passive IRQ\n");
+				stats->dev_stats.error_passive++;
+
+				cf->can_id |= CAN_ERR_CRTL;
+				cf->data[1] = (bec.txerr > bec.rxerr) ? CAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;
+			}
+			break;
+		case CAN_STATE_BUS_OFF:
+			dev_dbg(&f_dev->dev, "do_state BUG! hardware recovered automatically from BUS_OFF\n");
+			break;
+		default:
+			break;
 	}
 
 	/* process state changes depending on the new state */
 	switch (new_state) {
-	case CAN_STATE_ERROR_ACTIVE:
-		netdev_dbg(dev, "Error Active\n");
-		cf->can_id |= CAN_ERR_PROT;
-		cf->data[2] = CAN_ERR_PROT_ACTIVE;
-		break;
-	case CAN_STATE_BUS_OFF:
-		cf->can_id |= CAN_ERR_BUSOFF;
-		can_bus_off(dev);
-		break;
-	default:
-		break;
+		case CAN_STATE_ERROR_ACTIVE:
+			dev_dbg(&f_dev->dev, "do_state Error Active\n");
+			cf->can_id |= CAN_ERR_PROT;
+			cf->data[2] = CAN_ERR_PROT_ACTIVE;
+			break;
+		case CAN_STATE_BUS_OFF:
+			cf->can_id |= CAN_ERR_BUSOFF;
+			// can_bus_off(dev);
+			stats->dev_stats.bus_off++;
+			break;
+		default:
+			break;
 	}
 }
 
-static int flexcan_poll_state(struct net_device *dev, u32 reg_esr)
-{
-	struct flexcan_priv *priv = netdev_priv(dev);
-	struct sk_buff *skb;
-	struct can_frame *cf;
-	enum can_state new_state;
-	int flt;
-
-	flt = reg_esr & FLEXCAN_ESR_FLT_CONF_MASK;
-	if (likely(flt == FLEXCAN_ESR_FLT_CONF_ACTIVE)) {
-		if (likely(!(reg_esr & (FLEXCAN_ESR_TX_WRN |
-					FLEXCAN_ESR_RX_WRN))))
-			new_state = CAN_STATE_ERROR_ACTIVE;
-		else
-			new_state = CAN_STATE_ERROR_WARNING;
-	} else if (unlikely(flt == FLEXCAN_ESR_FLT_CONF_PASSIVE))
-		new_state = CAN_STATE_ERROR_PASSIVE;
-	else
-		new_state = CAN_STATE_BUS_OFF;
+// ##########################################################################################################################################
+// ##########################################################################################################################################
 
-	/* state hasn't changed */
-	if (likely(new_state == priv->can.state))
-		return 0;
+static irqreturn_t flexcan_irq(int irq, void *dev_id)
+{
+	const u8 dev_num = (irq - FLEXCAN_IRQ_BASE);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_stats *stats = &f_dev->stats;
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
+	struct flexcan_mb __iomem *mb = &regs->cantxfg[0];
+	struct timeval time;
+	u32 reg_iflag1, reg_esr;
+	u32 read_frames = 0;
 
-	skb = alloc_can_err_skb(dev, &cf);
-	if (unlikely(!skb))
-		return 0;
+	// flexcan_transceiver_switch(f_dev->pdata, 1);
+	reg_iflag1 = flexcan_read(&regs->iflag1);
+	reg_esr = flexcan_read(&regs->esr);
+	stats->int_num++;	/* Считаем прерывания */
 
-	do_state(dev, cf, new_state);
-	priv->can.state = new_state;
-	netif_receive_skb(skb);
+	if(reg_esr & FLEXCAN_ESR_WAK_INT) {
+		// if (fimx6d.version >= FLEXCAN_VER_10_0_12) {
+		// 	mxc_iomux_set_gpr_register(13, 28, 1, 0);
+		// }
+		flexcan_write(FLEXCAN_ESR_WAK_INT, &regs->esr);
+	}
 
-	dev->stats.rx_packets++;
-	dev->stats.rx_bytes += cf->can_dlc;
+	if (reg_iflag1 & FLEXCAN_IFLAG_DEFAULT)	{
+		if(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {
+			stats->err_over++;
+			stats->err_drop++;
+		}
+		else if(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_WARN) {
+			stats->err_warn++;
+		}
+		stats->int_rx_frame++;
 
-	return 1;
-}
+		read_frames = 0;
+		while((read_frames < 10) && (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE)) {	
+			do_gettimeofday(&time);
+			stats->rx_bytes += ((mb->can_ctrl >> 16) & 0xf);
+			if(flexcan_recv_buf_push(dev_num, mb, &time)) { /* буффер заполнен */
+				stats->err_drop++;
+				stats->err_fifo++;
+			}
+			else {	/* все хорошо */
+				stats->rx_frames++;
+			}
+
+			if(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {
+				flexcan_write((FLEXCAN_IFLAG_DEFAULT), &regs->iflag1);
+			}
+			else if(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_WARN) {
+				flexcan_write((FLEXCAN_IFLAG_RX_FIFO_WARN | FLEXCAN_IFLAG_RX_FIFO_AVAILABLE), &regs->iflag1);
+			}
+			else if(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE) {
+				flexcan_write(FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &regs->iflag1);
+			}
+
+			reg_iflag1 = flexcan_read(&regs->iflag1);
+			flexcan_read(&regs->timer);
+			read_frames++;
+		}
+	}
 
-static void flexcan_read_fifo(const struct net_device *dev,
-			      struct can_frame *cf)
-{
-	const struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
-	struct flexcan_mb __iomem *mb = &regs->cantxfg[0];
-	u32 reg_ctrl, reg_id;
+	if((reg_esr & FLEXCAN_ESR_ERR_STATE) || (flexcan_has_and_handle_berr(stats, reg_esr))) {
+		stats->int_state++;
 
-	reg_ctrl = flexcan_read(&mb->can_ctrl);
-	reg_id = flexcan_read(&mb->can_id);
-	if (reg_ctrl & FLEXCAN_MB_CNT_IDE)
-		cf->can_id = ((reg_id >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;
-	else
-		cf->can_id = (reg_id >> 18) & CAN_SFF_MASK;
+		stats->reg_esr = reg_esr & FLEXCAN_ESR_ERR_BUS;
+		flexcan_write(reg_esr, &regs->esr);
+		flexcan_write(f_dev->reg_ctrl_default, &regs->ctrl);			
+	}
 
-	if (reg_ctrl & FLEXCAN_MB_CNT_RTR)
-		cf->can_id |= CAN_RTR_FLAG;
-	cf->can_dlc = get_can_dlc((reg_ctrl >> 16) & 0xf);
+	if(reg_iflag1 & (1 << FLEXCAN_TX_BUF_ID)) {	/* transmission complete interrupt */
+		stats->int_tx_frame++;	/* tx_bytes is incremented in flexcan_start_xmit */
+		stats->tx_frames++;
+		flexcan_write((1 << FLEXCAN_TX_BUF_ID), &regs->iflag1);
+	}
 
-	*(__be32 *)(cf->data + 0) = cpu_to_be32(flexcan_read(&mb->data[0]));
-	*(__be32 *)(cf->data + 4) = cpu_to_be32(flexcan_read(&mb->data[1]));
+	if(read_frames != 0) {	/* Будим читателей */
+		wake_up_interruptible(&f_dev->inq); /* blocked in read() and select() */
+		if(f_dev->async_queue) {	/* and signal asynchronous readers, explained late in chapter 5 */
+			kill_fasync(&f_dev->async_queue, SIGIO, POLL_IN);
+		}
+	}
 
-	/* mark as read */
-	flexcan_write(FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &regs->iflag1);
-	flexcan_read(&regs->timer);
+	return IRQ_HANDLED;
 }
 
-static int flexcan_read_frame(struct net_device *dev)
-{
-	struct net_device_stats *stats = &dev->stats;
-	struct can_frame *cf;
-	struct sk_buff *skb;
+// ##########################################################################################################################################
+// ##########################################################################################################################################
 
-	skb = alloc_can_skb(dev, &cf);
-	if (unlikely(!skb)) {
-		stats->rx_dropped++;
-		return 0;
-	}
 
-	flexcan_read_fifo(dev, cf);
-	netif_receive_skb(skb);
+static int flexcan_chip_freeze(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
+	unsigned int timeout = 1000 * 1000 * 10 / f_dev->bittiming.bitrate;
+	u32 reg;
+
+	reg = flexcan_read(&regs->mcr);
+	reg |= FLEXCAN_MCR_HALT;
+	flexcan_write(reg, &regs->mcr);
 
-	stats->rx_packets++;
-	stats->rx_bytes += cf->can_dlc;
+	while (timeout-- && !(flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))
+		udelay(100);
 
-	can_led_event(dev, CAN_LED_EVENT_RX);
+	if (!(flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))
+		return -ETIMEDOUT;
 
-	return 1;
+	return 0;
 }
 
-static int flexcan_poll(struct napi_struct *napi, int quota)
+static int flexcan_chip_unfreeze(const u8 dev_num)
 {
-	struct net_device *dev = napi->dev;
-	const struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
-	u32 reg_iflag1, reg_esr;
-	int work_done = 0;
-
-	/*
-	 * The error bits are cleared on read,
-	 * use saved value from irq handler.
-	 */
-	reg_esr = flexcan_read(&regs->esr) | priv->reg_esr;
-
-	/* handle state changes */
-	work_done += flexcan_poll_state(dev, reg_esr);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
+	unsigned int timeout = FLEXCAN_TIMEOUT_US / 10;
+	u32 reg;
 
-	/* handle RX-FIFO */
-	reg_iflag1 = flexcan_read(&regs->iflag1);
-	while (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE &&
-	       work_done < quota) {
-		work_done += flexcan_read_frame(dev);
-		reg_iflag1 = flexcan_read(&regs->iflag1);
-	}
+	reg = flexcan_read(&regs->mcr);
+	reg &= ~FLEXCAN_MCR_HALT;
+	flexcan_write(reg, &regs->mcr);
 
-	/* report bus errors */
-	if (flexcan_has_and_handle_berr(priv, reg_esr) && work_done < quota)
-		work_done += flexcan_poll_bus_err(dev, reg_esr);
+	while (timeout-- && (flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))
+		udelay(10);
 
-	if (work_done < quota) {
-		napi_complete(napi);
-		/* enable IRQs */
-		flexcan_write(FLEXCAN_IFLAG_DEFAULT, &regs->imask1);
-		flexcan_write(priv->reg_ctrl_default, &regs->ctrl);
-	}
+	if (flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK)
+		return -ETIMEDOUT;
 
-	return work_done;
+	return 0;
 }
 
-static irqreturn_t flexcan_irq(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-	struct net_device_stats *stats = &dev->stats;
-	struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
-	u32 reg_iflag1, reg_esr;
-
-	reg_iflag1 = flexcan_read(&regs->iflag1);
-	reg_esr = flexcan_read(&regs->esr);
-	/* ACK all bus error and state change IRQ sources */
-	if (reg_esr & FLEXCAN_ESR_ALL_INT)
-		flexcan_write(reg_esr & FLEXCAN_ESR_ALL_INT, &regs->esr);
 
-	if (reg_esr & FLEXCAN_ESR_WAK_INT)
-		flexcan_exit_stop_mode(priv);
+static int flexcan_chip_softreset(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
+	unsigned int timeout = FLEXCAN_TIMEOUT_US / 10;
 
-	/*
-	 * schedule NAPI in case of:
-	 * - rx IRQ
-	 * - state change IRQ
-	 * - bus error IRQ and bus error reporting is activated
-	 */
-	if ((reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE) ||
-	    (reg_esr & FLEXCAN_ESR_ERR_STATE) ||
-	    flexcan_has_and_handle_berr(priv, reg_esr)) {
-		/*
-		 * The error bits are cleared on read,
-		 * save them for later use.
-		 */
-		priv->reg_esr = reg_esr & FLEXCAN_ESR_ERR_BUS;
-		flexcan_write(FLEXCAN_IFLAG_DEFAULT &
-			~FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &regs->imask1);
-		flexcan_write(priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL,
-		       &regs->ctrl);
-		napi_schedule(&priv->napi);
-	}
-
-	/* FIFO overflow */
-	if (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {
-		flexcan_write(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW, &regs->iflag1);
-		dev->stats.rx_over_errors++;
-		dev->stats.rx_errors++;
-	}
-
-	/* transmission complete interrupt */
-	if (reg_iflag1 & (1 << FLEXCAN_TX_BUF_ID)) {
-		stats->tx_bytes += can_get_echo_skb(dev, 0);
-		stats->tx_packets++;
-		can_led_event(dev, CAN_LED_EVENT_TX);
-		flexcan_write((1 << FLEXCAN_TX_BUF_ID), &regs->iflag1);
-		netif_wake_queue(dev);
+	flexcan_write(FLEXCAN_MCR_SOFTRST, &regs->mcr);
+	while (timeout-- && (flexcan_read(&regs->mcr) & FLEXCAN_MCR_SOFTRST)) {
+		udelay(10);
 	}
 
-	return IRQ_HANDLED;
+	if (flexcan_read(&regs->mcr) & FLEXCAN_MCR_SOFTRST)
+		return -ETIMEDOUT;
+
+	return 0;
 }
 
-static void flexcan_set_bittiming(struct net_device *dev)
+
+static void flexcan_set_bittiming(const u8 dev_num, const u32 reg_ctrl)
 {
-	const struct flexcan_priv *priv = netdev_priv(dev);
-	const struct can_bittiming *bt = &priv->can.bittiming;
-	struct flexcan_regs __iomem *regs = priv->base;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_stats *stats = &f_dev->stats;
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
 	u32 reg;
 
 	reg = flexcan_read(&regs->ctrl);
-	reg &= ~(FLEXCAN_CTRL_PRESDIV(0xff) |
-		 FLEXCAN_CTRL_RJW(0x3) |
-		 FLEXCAN_CTRL_PSEG1(0x7) |
-		 FLEXCAN_CTRL_PSEG2(0x7) |
-		 FLEXCAN_CTRL_PROPSEG(0x7) |
-		 FLEXCAN_CTRL_LPB |
-		 FLEXCAN_CTRL_SMP |
-		 FLEXCAN_CTRL_LOM);
-
-	reg |= FLEXCAN_CTRL_PRESDIV(bt->brp - 1) |
-		FLEXCAN_CTRL_PSEG1(bt->phase_seg1 - 1) |
-		FLEXCAN_CTRL_PSEG2(bt->phase_seg2 - 1) |
-		FLEXCAN_CTRL_RJW(bt->sjw - 1) |
-		FLEXCAN_CTRL_PROPSEG(bt->prop_seg - 1);
-
-	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
-		reg |= FLEXCAN_CTRL_LPB;
-	if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)
-		reg |= FLEXCAN_CTRL_LOM;
-	if (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
-		reg |= FLEXCAN_CTRL_SMP;
+	reg &= ~(FLEXCAN_BTRT_MASK | FLEXCAN_CTRL_LPB | FLEXCAN_CTRL_SMP | FLEXCAN_CTRL_LOM);
+	reg |= reg_ctrl;
 
-	netdev_info(dev, "writing ctrl=0x%08x\n", reg);
+	dev_dbg(&f_dev->dev, "flexcan_set_bittiming writing ctrl = %#08x\n", reg);
 	flexcan_write(reg, &regs->ctrl);
+	stats->reg_mcr = flexcan_read(&regs->mcr);
+	stats->reg_ctrl = flexcan_read(&regs->ctrl);
 
 	/* print chip status */
-	netdev_dbg(dev, "%s: mcr=0x%08x ctrl=0x%08x\n", __func__,
-		   flexcan_read(&regs->mcr), flexcan_read(&regs->ctrl));
+	dev_dbg(&f_dev->dev, "flexcan_set_bittiming mcr = %#08x ctrl = %#08x\n", flexcan_read(&regs->mcr), flexcan_read(&regs->ctrl));
 }
 
-/*
- * flexcan_chip_start
- *
- * this functions is entered with clocks enabled
- *
- */
-static int flexcan_chip_start(struct net_device *dev)
+
+static int flexcan_chip_start(const u8 dev_num)
 {
-	struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
-	int err;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_stats *stats = &f_dev->stats;
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
 	u32 reg_mcr, reg_ctrl;
+	int i, err;
 
-	/* enable module */
-	flexcan_chip_enable(priv);
+	flexcan_chip_enable(f_dev->f_base);	/* enable module */
 
 	/* soft reset */
-	flexcan_write(FLEXCAN_MCR_SOFTRST, &regs->mcr);
-	udelay(10);
-
-	reg_mcr = flexcan_read(&regs->mcr);
-	if (reg_mcr & FLEXCAN_MCR_SOFTRST) {
-		netdev_err(dev, "Failed to softreset can module (mcr=0x%08x)\n",
-			   reg_mcr);
-		err = -ENODEV;
-		goto out;
+	err = flexcan_chip_softreset(dev_num);
+	if (err) {
+		goto out_chip_disable;
 	}
 
-	flexcan_set_bittiming(dev);
+	flexcan_set_bittiming(dev_num, f_dev->reg_ctrl_bittiming);
 
-	/*
-	 * MCR
-	 *
-	 * enable freeze
-	 * enable fifo
-	 * halt now
-	 * only supervisor access
-	 * enable warning int
-	 * choose format C
-	 * disable local echo
-	 * enable self wakeup
+	/* MCR
+	 * enable freeze | enable fifo | halt now  | only supervisor access  | 
+	 * enable warning int |  choose format C  | enable self wakeup
 	 */
 	reg_mcr = flexcan_read(&regs->mcr);
-	reg_mcr &= ~FLEXCAN_MCR_MAXMB(0xff);
-	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |
-		FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |
-		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_SRX_DIS |
-		FLEXCAN_MCR_WAK_MSK | FLEXCAN_MCR_SLF_WAK |
-		FLEXCAN_MCR_MAXMB(FLEXCAN_TX_BUF_ID);
-	netdev_dbg(dev, "%s: writing mcr=0x%08x", __func__, reg_mcr);
+	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT | FLEXCAN_MCR_SUPV | 
+		FLEXCAN_MCR_WRN_EN | FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_WAK_MSK | FLEXCAN_MCR_SLF_WAK;
+	
+	dev_dbg(&f_dev->dev, "flexcan_chip_start writing mcr = %#08x\n", reg_mcr);
 	flexcan_write(reg_mcr, &regs->mcr);
-
-	/*
-	 * CTRL
-	 *
-	 * disable timer sync feature
-	 *
-	 * disable auto busoff recovery
-	 * transmit lowest buffer first
-	 *
-	 * enable tx and rx warning interrupt
-	 * enable bus off interrupt
-	 * (== FLEXCAN_CTRL_ERR_STATE)
+	stats->reg_mcr = flexcan_read(&regs->mcr);
+	/* CTRL
+	 * disable timer sync feature | disable auto busoff recovery | transmit lowest buffer first
+	 * enable tx and rx warning interrupt | enable bus off interrupt (== FLEXCAN_CTRL_ERR_STATE)
+	 * _note_: we enable the "error interrupt" (FLEXCAN_CTRL_ERR_MSK), too. Otherwise we don't get any
+	 * Otherwise we don't get any warning or bus passive interrupts.
 	 */
 	reg_ctrl = flexcan_read(&regs->ctrl);
 	reg_ctrl &= ~FLEXCAN_CTRL_TSYN;
-	reg_ctrl |= FLEXCAN_CTRL_BOFF_REC | FLEXCAN_CTRL_LBUF |
-		FLEXCAN_CTRL_ERR_STATE;
-	/*
-	 * enable the "error interrupt" (FLEXCAN_CTRL_ERR_MSK),
-	 * on most Flexcan cores, too. Otherwise we don't get
-	 * any error warning or passive interrupts.
-	 */
-	if (priv->devtype_data->features & FLEXCAN_HAS_BROKEN_ERR_STATE ||
-	    priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
-		reg_ctrl |= FLEXCAN_CTRL_ERR_MSK;
-
-	/* save for later use */
-	priv->reg_ctrl_default = reg_ctrl;
-	netdev_dbg(dev, "%s: writing ctrl=0x%08x", __func__, reg_ctrl);
-	flexcan_write(reg_ctrl, &regs->ctrl);
+	// reg_ctrl |= /*FLEXCAN_CTRL_BOFF_REC | */ FLEXCAN_CTRL_LBUF |/*| FLEXCAN_CTRL_ERR_STATE | */FLEXCAN_CTRL_ERR_MSK ;
+	reg_ctrl |= FLEXCAN_CTRL_BOFF_REC | FLEXCAN_CTRL_LBUF;
+
+	f_dev->reg_ctrl_default = reg_ctrl;	/* save for later use */
 
-	/* Abort any pending TX, mark Mailbox as INACTIVE */
-	flexcan_write(FLEXCAN_MB_CNT_CODE(0x4),
-		      &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);
+	dev_dbg(&f_dev->dev, "flexcan_chip_start writing ctrl = %#08x\n", reg_ctrl);
+	flexcan_write(reg_ctrl, &regs->ctrl);
+	stats->reg_ctrl = flexcan_read(&regs->ctrl);
 
+	for (i = 0; i < ARRAY_SIZE(regs->cantxfg); i++) {
+		flexcan_write(0, &regs->cantxfg[i].can_ctrl);
+		flexcan_write(0, &regs->cantxfg[i].can_id);
+		flexcan_write(0, &regs->cantxfg[i].data[0]);
+		flexcan_write(0, &regs->cantxfg[i].data[1]);
+		/* put MB into rx queue */
+		flexcan_write(FLEXCAN_MB_CNT_CODE(0x4), &regs->cantxfg[i].can_ctrl);
+	}
 	/* acceptance mask/acceptance code (accept everything) */
 	flexcan_write(0x0, &regs->rxgmask);
 	flexcan_write(0x0, &regs->rx14mask);
 	flexcan_write(0x0, &regs->rx15mask);
 
-	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES)
+	if(fimx6d.version >= FLEXCAN_VER_10_0_12) {	/* clear rx fifo global mask */
 		flexcan_write(0x0, &regs->rxfgmask);
+	}
+	// flexcan_transceiver_switch(priv, 1);						//заменить priv  на pdata из структуры вызывающего устройства
 
-	flexcan_transceiver_switch(priv, 1);
+	// MY INSERT: не поддерживается, нужно добавить
+	/*
+	 * On Vybrid, disable memory error detection interrupts
+	 * and freeze mode.
+	 * This also works around errata e5295 which generates
+	 * false positive memory errors and put the device in
+	 * freeze mode.
+	 */
+	// if (priv->devtype_data->features & FLEXCAN_HAS_MECR_FEATURES) {
+		
+	// 	 * Follow the protocol as described in "Detection
+	// 	 * and Correction of Memory Errors" to write to
+	// 	 * MECR register
+		 
+	// 	reg_crl2 = flexcan_read(&regs->crl2);
+	// 	reg_crl2 |= FLEXCAN_CRL2_ECRWRE;
+	// 	flexcan_write(reg_crl2, &regs->crl2);
+
+	// 	reg_mecr = flexcan_read(&regs->mecr);
+	// 	reg_mecr &= ~FLEXCAN_MECR_ECRWRDIS;
+	// 	flexcan_write(reg_mecr, &regs->mecr);
+	// 	reg_mecr &= ~(FLEXCAN_MECR_NCEFAFRZ | FLEXCAN_MECR_HANCEI_MSK |
+	// 			FLEXCAN_MECR_FANCEI_MSK);
+	// 	flexcan_write(reg_mecr, &regs->mecr);
+	// }
 
-	/* synchronize with the can bus */
-	reg_mcr = flexcan_read(&regs->mcr);
-	reg_mcr &= ~FLEXCAN_MCR_HALT;
-	flexcan_write(reg_mcr, &regs->mcr);
 
-	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+	/* synchronize with the can bus */
+	 err = flexcan_chip_unfreeze(dev_num);
+	if (err) {
+		goto out_transceiver_disable;
+	}
+	// reg_mcr = flexcan_read(&regs->mcr);
+	// reg_mcr &= ~FLEXCAN_MCR_HALT;
+	// flexcan_write(reg_mcr, &regs->mcr);
+	stats->reg_mcr = flexcan_read(&regs->mcr);
+	stats->state = CAN_STATE_ERROR_ACTIVE;
 
-	/* enable FIFO interrupts */
-	flexcan_write(FLEXCAN_IFLAG_DEFAULT, &regs->imask1);
+	flexcan_write(FLEXCAN_IFLAG_DEFAULT, &regs->imask1);	/* enable FIFO interrupts */
 
 	/* print chip status */
-	netdev_dbg(dev, "%s: reading mcr=0x%08x ctrl=0x%08x\n", __func__,
-		   flexcan_read(&regs->mcr), flexcan_read(&regs->ctrl));
+	dev_dbg(&f_dev->dev, "flexcan_chip_start reading mcr = %#08x ctrl = %#08x\n", flexcan_read(&regs->mcr), flexcan_read(&regs->ctrl));
+#ifdef FLEXCAN_USE_PROC_FS
+	flexcan_proc_file_init(dev_num);
+#endif
 
 	return 0;
-
- out:
-	flexcan_chip_disable(priv);
+ out_transceiver_disable:
+	flexcan_transceiver_disable(dev_num);
+ out_chip_disable:
+ 	dev_dbg(&f_dev->dev, "flexcan_chip_start chip disable\n");
+	flexcan_chip_disable(f_dev->f_base);
 	return err;
 }
 
-/*
- * flexcan_chip_stop
- *
- * this functions is entered with clocks enabled
- *
- */
-static void flexcan_chip_stop(struct net_device *dev)
+
+static void flexcan_chip_stop(const u8 dev_num)
 {
-	struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_stats *stats = &f_dev->stats;
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
 	u32 reg;
+	
+	regs = f_dev->f_base;
+#ifdef FLEXCAN_USE_PROC_FS
+	flexcan_proc_file_exit(dev_num);
+#endif
 
-	/* Disable all interrupts */
-	flexcan_write(0, &regs->imask1);
+	flexcan_write(0, &regs->imask1);	/* Disable all interrupts */
+	flexcan_write(f_dev->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL, &regs->ctrl);
 
 	/* Disable + halt module */
 	reg = flexcan_read(&regs->mcr);
 	reg |= FLEXCAN_MCR_MDIS | FLEXCAN_MCR_HALT;
 	flexcan_write(reg, &regs->mcr);
+	stats->reg_mcr = flexcan_read(&regs->mcr);
 
-	flexcan_transceiver_switch(priv, 0);
-	priv->can.state = CAN_STATE_STOPPED;
-
-	return;
+	// flexcan_transceiver_switch(priv, 0);	//заменить priv  на pdata из структуры вызывающего устройства
+	stats->state = CAN_STATE_STOPPED;
 }
 
-static int flexcan_open(struct net_device *dev)
+
+static int flexcan_open(const u8 dev_num)
 {
-	struct flexcan_priv *priv = netdev_priv(dev);
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	unsigned int irq = f_dev->irq_num;
 	int err;
 
-	clk_prepare_enable(priv->clk_ipg);
-	clk_prepare_enable(priv->clk_per);
+	err = clk_prepare_enable(f_dev->clk_ipg);
+	if (err) {
+		return err;
+	}
 
-	err = open_candev(dev);
-	if (err)
-		goto out;
-
-	err = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);
-	if (err)
-		goto out_close;
-
-	/* start chip and queuing */
-	err = flexcan_chip_start(dev);
-	if (err)
-		goto out_free_irq;
+	err = clk_prepare_enable(f_dev->clk_per);
+	if (err) {
+		goto out_disable_ipg;
+	}
 
-	can_led_event(dev, CAN_LED_EVENT_OPEN);
+	err = request_irq(irq, flexcan_irq, IRQF_SHARED, f_dev->name, f_dev->pdata);
+	if(err)	{
+		dev_dbg(&f_dev->dev, "flexcan_open request irq %d failed with err = %d\n", irq, err);
+		goto out_disable_per;
+	}
 
-	napi_enable(&priv->napi);
-	netif_start_queue(dev);
+	err = flexcan_chip_start(dev_num);	/* start chip and queuing */
+	if(err)	{
+		goto out_free_irq;
+	}
 
 	return 0;
 
  out_free_irq:
-	free_irq(dev->irq, dev);
- out_close:
-	close_candev(dev);
- out:
-	clk_disable_unprepare(priv->clk_per);
-	clk_disable_unprepare(priv->clk_ipg);
+	free_irq(irq, f_dev->pdata);
+ out_disable_per:
+	clk_disable_unprepare(f_dev->clk_per);
+ out_disable_ipg:
+	clk_disable_unprepare(f_dev->clk_ipg);
 
 	return err;
 }
 
-static int flexcan_close(struct net_device *dev)
-{
-	struct flexcan_priv *priv = netdev_priv(dev);
 
-	netif_stop_queue(dev);
-	napi_disable(&priv->napi);
-	flexcan_chip_stop(dev);
+static int flexcan_close(const u8 dev_num)
+{
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	unsigned int irq = f_dev->irq_num;
 
-	free_irq(dev->irq, dev);
-	clk_disable_unprepare(priv->clk_per);
-	clk_disable_unprepare(priv->clk_ipg);
+	flexcan_chip_stop(dev_num);
 
-	close_candev(dev);
+	free_irq(irq, f_dev->pdata);
 
-	can_led_event(dev, CAN_LED_EVENT_STOP);
+	clk_disable_unprepare(f_dev->clk_per);
+	clk_disable_unprepare(f_dev->clk_ipg);
 
 	return 0;
 }
 
-static int flexcan_set_mode(struct net_device *dev, enum can_mode mode)
+
+static int flexcan_set_mode(__u8 dev_num, enum can_mode mode)
 {
-	int err;
+	int err = 0;
 
 	switch (mode) {
 	case CAN_MODE_START:
-		err = flexcan_chip_start(dev);
-		if (err)
+		err = flexcan_chip_start(dev_num);
+		if (err)	{
 			return err;
-
-		netif_wake_queue(dev);
+		}
 		break;
-
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -969,112 +1841,82 @@
 	return 0;
 }
 
-static const struct net_device_ops flexcan_netdev_ops = {
-	.ndo_open	= flexcan_open,
-	.ndo_stop	= flexcan_close,
-	.ndo_start_xmit	= flexcan_start_xmit,
-};
 
-static int register_flexcandev(struct net_device *dev)
+static int register_flexcandev(const u8 dev_num)
 {
-	struct flexcan_priv *priv = netdev_priv(dev);
-	struct flexcan_regs __iomem *regs = priv->base;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	struct flexcan_regs __iomem *regs = f_dev->f_base;
 	u32 reg, err;
 
-	clk_prepare_enable(priv->clk_ipg);
-	clk_prepare_enable(priv->clk_per);
+	err = clk_prepare_enable(f_dev->clk_ipg);
+	if (err) {
+		return err;
+	}
+
+	err = clk_prepare_enable(f_dev->clk_per);
+	if (err) {
+		goto out_disable_ipg;
+	}
 
 	/* select "bus clock", chip must be disabled */
-	flexcan_chip_disable(priv);
+	flexcan_chip_disable(f_dev->f_base);
+	if (err) {
+		goto out_disable_per;
+	}
 	reg = flexcan_read(&regs->ctrl);
 	reg |= FLEXCAN_CTRL_CLK_SRC;
 	flexcan_write(reg, &regs->ctrl);
 
-	flexcan_chip_enable(priv);
-
+	flexcan_chip_enable(f_dev->f_base);
+	if (err) {
+		goto out_chip_disable;
+	}
 	/* set freeze, halt and activate FIFO, restrict register access */
 	reg = flexcan_read(&regs->mcr);
-	reg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT |
-		FLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;
+	reg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT | FLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;
 	flexcan_write(reg, &regs->mcr);
 
-	/*
-	 * Currently we only support newer versions of this core
+	/* Currently we only support newer versions of this core
 	 * featuring a RX FIFO. Older cores found on some Coldfire
 	 * derivates are not yet supported.
 	 */
 	reg = flexcan_read(&regs->mcr);
 	if (!(reg & FLEXCAN_MCR_FEN)) {
-		netdev_err(dev, "Could not enable RX FIFO, unsupported core\n");
+		dev_dbg(&f_dev->dev, "Could not enable RX FIFO, unsupported core\n");
 		err = -ENODEV;
-		goto out;
+		goto out_chip_disable;
 	}
 
-	err = register_candev(dev);
-
- out:
+ out_chip_disable:
 	/* disable core and turn off clocks */
-	flexcan_chip_disable(priv);
-	clk_disable_unprepare(priv->clk_per);
-	clk_disable_unprepare(priv->clk_ipg);
+ 	flexcan_chip_disable(f_dev->f_base);
+ out_disable_per:
+	clk_disable_unprepare(f_dev->clk_per);
+ out_disable_ipg:
+	clk_disable_unprepare(f_dev->clk_ipg);
 
 	return err;
 }
 
-static void unregister_flexcandev(struct net_device *dev)
-{
-	unregister_candev(dev);
-}
-
-static int flexcan_of_parse_stop_mode(struct platform_device *pdev)
-{
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct device_node *np = pdev->dev.of_node;
-	struct device_node *node;
-	struct flexcan_priv *priv;
-	phandle phandle;
-	u32 out_val[5];
-	int ret;
-
-	if (!np)
-		return -EINVAL;
-	/*
-	 * stop mode property format is:
-	 * <&gpr req_gpr req_bit ack_gpr ack_bit>.
-	 */
-	ret = of_property_read_u32_array(np, "stop-mode", out_val, 5);
-	if (ret) {
-		dev_dbg(&pdev->dev, "no stop-mode property\n");
-		return ret;
-	}
-	phandle = *out_val;
-
-	node = of_find_node_by_phandle(phandle);
-	if (!node) {
-		dev_dbg(&pdev->dev, "could not find gpr node by phandle\n");
-		return PTR_ERR(node);
-	}
-
-	priv = netdev_priv(dev);
-	priv->stm.gpr = syscon_node_to_regmap(node);
-	if (IS_ERR(priv->stm.gpr)) {
-		dev_dbg(&pdev->dev, "could not find gpr regmap\n");
-		return PTR_ERR(priv->stm.gpr);
-	}
-
-	of_node_put(node);
-
-	priv->stm.req_gpr = out_val[1];
-	priv->stm.req_bit = out_val[2];
-	priv->stm.ack_gpr = out_val[3];
-	priv->stm.ack_bit = out_val[4];
 
-	dev_dbg(&pdev->dev, "gpr %s req_gpr 0x%x req_bit %u ack_gpr 0x%x ack_bit %u\n",
-			node->full_name, priv->stm.req_gpr,
-			priv->stm.req_bit, priv->stm.ack_gpr,
-			priv->stm.ack_bit);
-	return 0;
-}
+// static struct platform_device_id flexcan_id_table[] = {
+// 	{
+// 		.name = "imx25-flexcan",
+// 		.driver_data = FLEXCAN_VER_3_0_0,
+// 	}, {
+// 		.name = "imx28-flexcan",
+// 		.driver_data = FLEXCAN_VER_3_0_4,
+// 	}, {
+// 		.name = "imx35-flexcan",
+// 		.driver_data = FLEXCAN_VER_3_0_0,
+// 	}, {
+// 		.name = "imx53-flexcan",
+// 		.driver_data = FLEXCAN_VER_3_0_0,
+// 	}, {
+// 		.name = "imx6q-flexcan",
+// 		.driver_data = FLEXCAN_VER_10_0_12,
+// 	},
+// };
 
 static const struct of_device_id flexcan_of_match[] = {
 	{ .compatible = "fsl,imx6q-flexcan", .data = &fsl_imx6q_devtype_data, },
@@ -1090,44 +1932,52 @@
 };
 MODULE_DEVICE_TABLE(platform, flexcan_id_table);
 
+
 static int flexcan_probe(struct platform_device *pdev)
 {
-	const struct of_device_id *of_id;
-	const struct flexcan_devtype_data *devtype_data;
-	struct net_device *dev;
-	struct flexcan_priv *priv;
+	const u8 dev_num = pdev->id;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	char name0[IFNAMSIZ] = "can0", name1[IFNAMSIZ] = "can1";
+	resource_size_t mem_size;
+	struct regulator *reg_xceiver;
 	struct resource *mem;
 	struct clk *clk_ipg = NULL, *clk_per = NULL;
-	struct pinctrl *pinctrl;
 	void __iomem *base;
-	resource_size_t mem_size;
-	int err, irq;
-	u32 clock_freq = 0;
-	int wakeup = 1;
-
-	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-	if (IS_ERR(pinctrl))
-		return PTR_ERR(pinctrl);
-
-	if (pdev->dev.of_node)
-		of_property_read_u32(pdev->dev.of_node,
-						"clock-frequency", &clock_freq);
+	int err, irq, major;
+    u32 clock_freq = 0;
+
+	printk("%s driver ver %s by Strim-tech\n", FLEXCAN_DRV_NAME, FLEXCAN_DRV_VER);
+
+	/* pdev->id 	- ID устройства (0 или 1)
+	 * dev->irq 	- IRQ number
+	 * dev->name 	- Имя устройства (can0 или can1)
+	 * pdev->id_entry->name - Имя родителя (imx6d-flexcan)
+	 */
+
+	reg_xceiver = devm_regulator_get(&pdev->dev, "xceiver");
+	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER) {
+		return -EPROBE_DEFER;
+	}
+	else if (IS_ERR(reg_xceiver)) {
+		reg_xceiver = NULL;
+	}
+
+	if (pdev->dev.of_node) {
+		of_property_read_u32(pdev->dev.of_node,	"clock-frequency", &clock_freq);
+	}
 
 	if (!clock_freq) {
 		clk_ipg = devm_clk_get(&pdev->dev, "ipg");
 		if (IS_ERR(clk_ipg)) {
 			dev_err(&pdev->dev, "no ipg clock defined\n");
-			err = PTR_ERR(clk_ipg);
-			goto failed_clock;
+			return PTR_ERR(clk_ipg);
 		}
 
 		clk_per = devm_clk_get(&pdev->dev, "per");
 		if (IS_ERR(clk_per)) {
 			dev_err(&pdev->dev, "no per clock defined\n");
-			err = PTR_ERR(clk_per);
-			goto failed_clock;
+			return PTR_ERR(clk_per);
 		}
-
 		clock_freq = clk_get_rate(clk_per);
 	}
 
@@ -1150,181 +2000,205 @@
 		goto failed_map;
 	}
 
-	dev = alloc_candev(sizeof(struct flexcan_priv), 1);
-	if (!dev) {
-		err = -ENOMEM;
-		goto failed_alloc;
-	}
-
-	of_id = of_match_device(flexcan_of_match, &pdev->dev);
-	if (of_id) {
-		devtype_data = of_id->data;
-	} else if (pdev->id_entry->driver_data) {
-		devtype_data = (struct flexcan_devtype_data *)
-			pdev->id_entry->driver_data;
-	} else {
-		err = -ENODEV;
-		goto failed_devtype;
-	}
-
-	dev->netdev_ops = &flexcan_netdev_ops;
-	dev->irq = irq;
-	dev->flags |= IFF_ECHO;
-
-	priv = netdev_priv(dev);
-	priv->can.clock.freq = clock_freq;
-	priv->can.bittiming_const = &flexcan_bittiming_const;
-	priv->can.do_set_mode = flexcan_set_mode;
-	priv->can.do_get_berr_counter = flexcan_get_berr_counter;
-	priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
-		CAN_CTRLMODE_LISTENONLY	| CAN_CTRLMODE_3_SAMPLES |
-		CAN_CTRLMODE_BERR_REPORTING;
-	priv->base = base;
-	priv->dev = dev;
-	priv->clk_ipg = clk_ipg;
-	priv->clk_per = clk_per;
-	priv->pdata = pdev->dev.platform_data;
-	priv->devtype_data = devtype_data;
-
-	priv->stby_gpio = of_get_named_gpio_flags(pdev->dev.of_node,
-						  "trx-stby-gpio", 0,
-						  &priv->stby_gpio_flags);
-	if (gpio_is_valid(priv->stby_gpio)){
-		gpio_request_one(priv->stby_gpio, GPIOF_DIR_OUT, "flexcan-trx-stby");
-		gpio_direction_output(priv->stby_gpio,1);
-	}
-
-	netif_napi_add(dev, &priv->napi, flexcan_poll, FLEXCAN_NAPI_WEIGHT);
-
-	dev_set_drvdata(&pdev->dev, dev);
-	SET_NETDEV_DEV(dev, &pdev->dev);
-
-	err = register_flexcandev(dev);
-	if (err) {
-		dev_err(&pdev->dev, "registering netdev failed\n");
-		goto failed_register;
+	flexcan_f_dev_init(f_dev);
+	f_dev->irq_num = irq;
+	f_dev->stats.freq = clock_freq;
+	f_dev->stats.bittiming_const = &flexcan_bittiming_const;
+	f_dev->do_set_mode = flexcan_set_mode;
+	f_dev->do_get_berr_counter = flexcan_get_berr_counter;
+	f_dev->stats.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK | CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_BERR_REPORTING;
+	f_dev->f_base = base;
+	f_dev->dev = pdev->dev;
+	f_dev->clk_ipg = clk_ipg;
+	f_dev->clk_per = clk_per;
+	f_dev->reg_xceiver = reg_xceiver;
+	f_dev->pdata = pdev->dev.platform_data;
+	fimx6d.version = pdev->id_entry->driver_data;
+	memcpy(fimx6d.name, pdev->id_entry->name, sizeof(fimx6d.name));
+	
+    if(dev_num == 0)	{
+		memcpy(f_dev->name, name0, sizeof(f_dev->name));
+    }
+    else if(dev_num == 1) 	{
+    	memcpy(f_dev->name, name1, sizeof(f_dev->name));
+    }
+
+	if(!fimx6d.is_init)	{
+		err = alloc_chrdev_region(&fimx6d.f_devt, FLEXCAN_DEV_FIRST, FLEXCAN_DEV_COUNT, fimx6d.name);
+		if (err < 0) {
+			err = -1;
+			dev_dbg(&f_dev->dev, "flexcan_probe alloc chrdev region failed\n");
+			goto err_reg_chrdev;
+		} 
+	}
+	major = MAJOR(fimx6d.f_devt);
+	dev_dbg(&f_dev->dev, "flexcan_probe major = %d, dev_num = %d\n",major, dev_num);	
+
+	f_dev->f_devt = MKDEV(major, dev_num);  
+			
+	cdev_init(&f_dev->f_cdev, &flexcan_fops);
+	f_dev->f_cdev.owner = THIS_MODULE;
+	f_dev->f_cdev.ops = &flexcan_fops;
+
+	err = cdev_add(&f_dev->f_cdev, f_dev->f_devt, 1);
+	if(err)	{
+		err = -1;
+		dev_dbg(&f_dev->dev, "flexcan_probe c_dev add error\n");
+		goto err_cdev_add;
+	}
+
+	if(!fimx6d.is_init)	{
+	    if ((fimx6d.f_class = class_create(THIS_MODULE, fimx6d.name)) == NULL)	{
+			err = -1;
+			dev_dbg(&f_dev->dev, "flexcan_probe class create error\n");
+			goto err_class_create;
+		}
+#ifdef FLEXCAN_USE_PROC_FS
+		flexcan_proc_dir_init(dev_num);
+#endif
 	}
 
-	devm_can_led_init(dev);
-
-	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
-		err = flexcan_of_parse_stop_mode(pdev);
-		if (err) {
-			wakeup = 0;
-			dev_dbg(&pdev->dev, "failed to parse stop-mode\n");
-		}
+	if (device_create(fimx6d.f_class, &pdev->dev, f_dev->f_devt, NULL, f_dev->name) == NULL)	{
+		err = -1;
+		dev_dbg(&f_dev->dev, "flexcan_probe device create error\n");
+		goto err_device_create;
 	}
 
-	device_set_wakeup_capable(&pdev->dev, wakeup);
+	if(!fimx6d.is_init)	{
+    	fimx6d.is_init = 1;
+    }
 
-	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",
-		 priv->base, dev->irq);
+    flexcan_open(dev_num);
 
 	return 0;
 
- failed_register:
- failed_devtype:
-	free_candev(dev);
- failed_alloc:
+ err_device_create:
+ 	if(!fimx6d.is_init)	{
+		class_destroy(fimx6d.f_class);
+	}
+ err_class_create:
+ err_cdev_add:	
+ 	if(!fimx6d.is_init)	{
+ 		unregister_chrdev_region(f_dev->f_devt, FLEXCAN_DEV_COUNT);
+ 	}
+ err_reg_chrdev:
 	iounmap(base);
  failed_map:
 	release_mem_region(mem->start, mem_size);
  failed_get:
+	//clk_put(clk);
  failed_clock:
 	return err;
 }
 
+
 static int flexcan_remove(struct platform_device *pdev)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct flexcan_priv *priv = netdev_priv(dev);
 	struct resource *mem;
+	const u8 dev_num = pdev->id;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
 
-	unregister_flexcandev(dev);
-	platform_set_drvdata(pdev, NULL);
-	iounmap(priv->base);
+	flexcan_close(dev_num);
+
+	// flexcan_proc_file_exit(dev_num);
+	device_destroy(fimx6d.f_class, f_dev->f_devt);
+	if(!fimx6d.is_init)	{
+#ifdef FLEXCAN_USE_PROC_FS
+		flexcan_proc_dir_exit();
+#endif
+		class_destroy(fimx6d.f_class);
+	}
+
+	cdev_del(&f_dev->f_cdev);
+	if(!fimx6d.is_init)	{
+		unregister_chrdev_region(f_dev->f_devt, FLEXCAN_DEV_COUNT);
+		// flexcan_proc_dir_exit();	/* нужно перенести, но куда?..... */
+	}
 
-	if (gpio_is_valid(priv->stby_gpio))
-		gpio_free(priv->stby_gpio);
+	if(fimx6d.is_init)	{
+    	fimx6d.is_init = 0;
+    }
+
+	platform_set_drvdata(pdev, NULL);
+	iounmap(f_dev->f_base);
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	release_mem_region(mem->start, resource_size(mem));
 
-	free_candev(dev);
+	// clk_put(f_dev->clk);
 
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int flexcan_suspend(struct platform_device *pdev, pm_message_t state)
+
+static int __maybe_unused flexcan_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct flexcan_priv *priv = netdev_priv(dev);
+	const u8 dev_num = pdev->id;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	int ret;
 
-	if (netif_running(dev)) {
-		netif_stop_queue(dev);
-		netif_device_detach(dev);
-		/*
-		* if wakeup is enabled, enter stop mode
-		* else enter disabled mode.
-		*/
-		if (device_may_wakeup(&pdev->dev)) {
-			enable_irq_wake(dev->irq);
-			flexcan_enter_stop_mode(priv);
-		} else {
-			flexcan_chip_disable(priv);
-		}
-	} else {
-		flexcan_chip_disable(priv);
+	f_dev->stats.state = CAN_STATE_SLEEPING;
+	//if(fimx6d.version >= FLEXCAN_VER_10_0_12) {	 // enable stop request for wakeup 
+	// 	mxc_iomux_set_gpr_register(13, 28, 1, 1);
+	// }
+
+	ret = irq_set_irq_wake(f_dev->irq_num, 1);
+	if(ret)	{
+		return ret;
 	}
-	priv->can.state = CAN_STATE_SLEEPING;
 
 	return 0;
 }
 
-static int flexcan_resume(struct platform_device *pdev)
-{
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct flexcan_priv *priv = netdev_priv(dev);
 
-	priv->can.state = CAN_STATE_ERROR_ACTIVE;
-	if (netif_running(dev)) {
-		netif_device_attach(dev);
-		netif_start_queue(dev);
+static int __maybe_unused flexcan_resume(struct platform_device *pdev)
+{
+	const u8 dev_num = pdev->id;
+	struct flexcan_chardev* f_dev = &fimx6d.f_dev[dev_num];
+	int ret;
 
-		if (device_may_wakeup(&pdev->dev)) {
-			disable_irq_wake(dev->irq);
-			flexcan_exit_stop_mode(priv);
-		} else {
-			flexcan_chip_enable(priv);
-		}
-	} else {
-		flexcan_chip_enable(priv);
+	ret = irq_set_irq_wake(f_dev->irq_num, 0);
+	if(ret)	{
+		return ret;
 	}
+	f_dev->stats.state = CAN_STATE_ERROR_ACTIVE;
 
 	return 0;
 }
-#else
-#define flexcan_suspend NULL
-#define flexcan_resume NULL
-#endif
+
+
+// static int __init flexcan_init(void)
+// {
+// 	return platform_driver_register(&flexcan_driver);
+// }
+
+
+// static void __exit flexcan_exit(void)
+// {
+// 	platform_driver_unregister(&flexcan_driver);
+// }
+
 
 static struct platform_driver flexcan_driver = {
 	.driver = {
-		.name = DRV_NAME,
-		.owner = THIS_MODULE,
+		.name = FLEXCAN_DRV_NAME,
+		// .pm = &flexcan_pm_ops,
 		.of_match_table = flexcan_of_match,
 	},
-	.probe = flexcan_probe,
-	.remove = flexcan_remove,
-	.suspend = flexcan_suspend,
-	.resume = flexcan_resume,
-	.id_table = flexcan_id_table,
+	.probe = 		flexcan_probe,
+	.id_table = 	flexcan_id_table,
+	.remove = 		flexcan_remove,
+	.suspend = 		flexcan_suspend,
+	.resume = 		flexcan_resume,
 };
 
+// module_init(flexcan_init);
+// module_exit(flexcan_exit);
+
 module_platform_driver(flexcan_driver);
 
 MODULE_AUTHOR("Sascha Hauer <kernel@pengutronix.de>, "
-	      "Marc Kleine-Budde <kernel@pengutronix.de>");
+	      "Marc Kleine-Budde <kernel@pengutronix.de>, "
+	      "Mikita Dzivakou <grommerin@gmail.com>");
 MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("CAN port driver for flexcan based chip");
+MODULE_DESCRIPTION("CAN port driver (with file operations) for flexcan based chip");



+++ a/drivers/net/can/chr_flexcan.h	2015-07-30 17:19:58.000000000 +0300
@@ -0,0 +1,189 @@
+#ifndef FLEXCAN_H
+#define FLEXCAN_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#include <linux/can/netlink.h>
+#include <linux/can/error.h>
+
+#define SET_DRIVER_CLEAR            (0)             /* For init setting variable */
+#define SET_DRIVER_DEBUG_MASK       0x000000f0      /* For check set debug in message */
+#define SET_DRIVER_DEBUG_ON         (0xC << 4)      /* Turn on debug messages in griver */
+#define SET_DRIVER_DEBUG_OFF        (0x0 << 4)      /* Turn off debug messages in griver */
+#define SET_DRIVER_DEBUG_L0         (0x8 << 4)      /* Set level of debug messages as 0, few reports */
+#define SET_DRIVER_DEBUG_L1         (0x1 << 4)      /* Set level of debug messages as 1, average reports */
+#define SET_DRIVER_DEBUG_L2         (0x2 << 4)      /* Set level of debug messages as 2, many reports */
+#define SET_DRIVER_DEBUG_L3         (0x3 << 4)      /* Set level of debug messages as 3, all reports */
+
+#define SET_CAN_BITRATE_MASK        0x00000f00      /* For check set bitrate in message */
+#define SET_CAN_BITRATE_1000        (0x1 << 8)      /* Set bitrate 1000 */
+#define SET_CAN_BITRATE_500         (0x2 << 8)      /* Set bitrate 500 */
+#define SET_CAN_BITRATE_250         (0x3 << 8)      /* Set bitrate 250 */
+#define SET_CAN_BITRATE_125         (0x4 << 8)      /* Set bitrate 125 */
+#define SET_CAN_BITRATE_100         (0x5 << 8)      /* Set bitrate 100 */
+
+#define SET_CAN_MODE_MASK           0x0000f000      /* For check set control mode in message */
+#define SET_CAN_MODE_LOOPBACK       (0x1 << 12)     /* Set bitrate 1000 */
+#define SET_CAN_MODE_LISTENONLY     (0x2 << 12)     /* Set bitrate 500 */
+#define SET_CAN_MODE_3_SAMPLES      (0x3 << 12)     /* Set bitrate 250 */
+#define SET_CAN_MODE_ONE_SHOT       (0x4 << 12)     /* Set bitrate 125 */
+#define SET_CAN_MODE_BERR_REPORTING (0x5 << 12)     /* Set bitrate 100 */
+
+/* controller area network (CAN) kernel definitions */
+
+/* fixed length of message with CAN data */
+#define CAN_DATA_MSG_LENGTH         (50)
+
+/* first char in CAN message */
+#define CAN_DATA_MSG_CHAR_START     '$'
+
+/*
+ * struct can_message - can message format structure
+ *
+ * $CAN,0,55f5a4d3,4f537,8000F00F,8,0807060504030201\n
+ *
+ * @mess_head:	head os message 
+ * @comma_%d:   separators 
+ * @dev_num:    device number 
+ * @time_sec:   message time (sec) 
+ * @time_usec:  message time (usec) 
+ * @can_id:     can ID 
+ * @can_dlc:    data length 
+ * @can_data:   can data 
+ * @mess_end:   end of message 
+ */
+struct can_message {
+	char mess_head[4];	/* "$CAN" */
+	char comma_0[1];	/* "," */
+	char dev_num[1];	/* %d */
+	char comma_1[1];	/* "," */
+	char time_sec[8];	/* %08x */
+	char comma_2[1];	/* "," */
+	char time_usec[5];	/* %05x */
+	char comma_3[1];	/* "," */
+	char can_id[8]; 	/* %08x */
+	char comma_4[1];	/* "," */
+	char can_dlc[1];	/* %d */
+	char comma_5[1];	/* "," */
+	char can_data[16];	/* %016llx */
+	char mess_end[1];	/* "\n" */
+};
+
+
+
+/**
+ * Controller Area Network Identifier structure
+ *
+ * bit 0-28: CAN identifier (11/29 bit)
+ * bit 29: error frame flag (0 = data frame, 1 = error frame)
+ * bit 30: remote transmission request flag (1 = rtr frame)
+ * bit 31: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
+ */
+#define CANID_T_
+typedef __u32 canid_t;
+
+/* special address description flags for the CAN_ID */
+#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
+#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
+#define CAN_ERR_FLAG 0x20000000U /* error frame */
+
+/* valid bits in CAN ID for frame formats */
+#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
+#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
+#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
+
+/**
+ * struct can_frame - basic CAN frame structure
+ * @can_id:  the CAN ID of the frame and CAN_*_FLAG flags, see above.
+ * @can_dlc: the data length field of the CAN frame
+ * @data:    the CAN frame payload.
+ */
+struct can_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    can_dlc; /* data length code: 0 .. 8 */
+	__u8    data[8] __attribute__((aligned(8)));
+};
+
+/**
+ * struct can_filter - CAN ID based filter in can_register().
+ *
+ * @can_id:   relevant bits of CAN ID which are not masked out.
+ * @can_mask: CAN mask (see description)
+ *
+ * Description:
+ * A filter matches, when
+ *          <received_can_id> & mask == can_id & mask
+ *
+ * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ * filter for error frames (CAN_ERR_FLAG bit set in mask).
+ */
+struct can_filter {
+	canid_t can_id;
+	canid_t can_mask;
+};
+
+enum can_mode {
+	CAN_MODE_STOP = 0,
+	CAN_MODE_START,
+	CAN_MODE_SLEEP
+};
+
+struct flexcan_mb {
+	__u32 can_ctrl;
+	__u32 can_id;
+	__u32 data[2];
+};
+
+struct flexcan_frame_cf {
+	struct can_frame cf;
+	struct timeval time;
+};
+
+struct flexcan_stats {
+	__u32 rx_frames;		// количество принятых фреймов
+	__u32 tx_frames;		// количество отправленных фреймов
+	/* возможно стоит предусмотреть увеличение счетчиков байт данных т.к. может переполниться за 8 часов */
+	__u32 rx_bytes;			// количество принятых байт данных
+	__u32 tx_bytes;			// количество отправленных байт данных
+
+	__u32 int_wak;			// количество прерываний пробуждения
+	__u32 int_state;		// количество прерываний проверки состояния
+	__u32 int_rx_frame;		// количество прерываний чтения фреймов
+	__u32 int_tx_frame;		// количество прерываний отправки фреймов
+	__u32 int_num;			// количество прерываний
+
+	__u32 err_tx;			// количество ошибок отправки фреймов
+	__u32 err_rx;			// количество ошибок принятия фреймов
+	__u32 err_over;			// количество переполнений буффера
+	__u32 err_warn;			// количество заполнений буффера
+	__u32 err_frame;		// количество ошибочных фреймов
+	__u32 err_drop;			// количество потерянных при чтении фреймов
+	__u32 err_length;		// количество ошибок длины фреймов
+	__u32 err_fifo;			// количество ошибок fifo буффера
+
+	__u32 reg_esr;			// состояние регистра esr
+	__u32 reg_mcr;			// состояние регистра mcr
+	__u32 reg_ctrl;			// состояние регистра ctrl
+
+	__u32 freq;				// частота модуля
+
+	__u32 ctrlmode;
+	__u32 ctrlmode_supported;
+
+	struct can_device_stats dev_stats;
+
+	enum can_state state;
+	struct can_bittiming_const *bittiming_const;
+};
+
+/* ioctl commands magic numder */
+#define FLEXCAN_IOC_MAGIC		0x81
+
+/* supported ioctl commands */
+//#define FLEXCAN_IOCTL_CMD 	_IO(FLEXCAN_IOC_MAGIC, 0x00)
+#define FLEXCAN_IOCTL_READ 		_IOR(FLEXCAN_IOC_MAGIC, 0x00, int *)
+#define FLEXCAN_IOCTL_WRITE 	_IOW(FLEXCAN_IOC_MAGIC, 0x01, int *)
+#define FLEXCAN_IOCTL_WR_RD		_IOWR(FLEXCAN_IOC_MAGIC, 0x02, int *)
+
+#endif
